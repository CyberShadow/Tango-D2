<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>tango.math.random.Random</title>
  <style type="text/css">
  .linescolumn > a { display: block; }
  td { vertical-align: top; }
  </style>
  <link href="html.css" rel="stylesheet" type="text/css">
</head>
<body>
<table><tr><td class="linescolumn"><a id="L1" href="#L1">1</a><a id="L2" href="#L2">2</a><a id="L3" href="#L3">3</a><a id="L4" href="#L4">4</a><a id="L5" href="#L5">5</a><a id="L6" href="#L6">6</a><a id="L7" href="#L7">7</a><a id="L8" href="#L8">8</a><a id="L9" href="#L9">9</a><a id="L10" href="#L10">10</a><a id="L11" href="#L11">11</a><a id="L12" href="#L12">12</a><a id="L13" href="#L13">13</a><a id="L14" href="#L14">14</a><a id="L15" href="#L15">15</a><a id="L16" href="#L16">16</a><a id="L17" href="#L17">17</a><a id="L18" href="#L18">18</a><a id="L19" href="#L19">19</a><a id="L20" href="#L20">20</a><a id="L21" href="#L21">21</a><a id="L22" href="#L22">22</a><a id="L23" href="#L23">23</a><a id="L24" href="#L24">24</a><a id="L25" href="#L25">25</a><a id="L26" href="#L26">26</a><a id="L27" href="#L27">27</a><a id="L28" href="#L28">28</a><a id="L29" href="#L29">29</a><a id="L30" href="#L30">30</a><a id="L31" href="#L31">31</a><a id="L32" href="#L32">32</a><a id="L33" href="#L33">33</a><a id="L34" href="#L34">34</a><a id="L35" href="#L35">35</a><a id="L36" href="#L36">36</a><a id="L37" href="#L37">37</a><a id="L38" href="#L38">38</a><a id="L39" href="#L39">39</a><a id="L40" href="#L40">40</a><a id="L41" href="#L41">41</a><a id="L42" href="#L42">42</a><a id="L43" href="#L43">43</a><a id="L44" href="#L44">44</a><a id="L45" href="#L45">45</a><a id="L46" href="#L46">46</a><a id="L47" href="#L47">47</a><a id="L48" href="#L48">48</a><a id="L49" href="#L49">49</a><a id="L50" href="#L50">50</a><a id="L51" href="#L51">51</a><a id="L52" href="#L52">52</a><a id="L53" href="#L53">53</a><a id="L54" href="#L54">54</a><a id="L55" href="#L55">55</a><a id="L56" href="#L56">56</a><a id="L57" href="#L57">57</a><a id="L58" href="#L58">58</a><a id="L59" href="#L59">59</a><a id="L60" href="#L60">60</a><a id="L61" href="#L61">61</a><a id="L62" href="#L62">62</a><a id="L63" href="#L63">63</a><a id="L64" href="#L64">64</a><a id="L65" href="#L65">65</a><a id="L66" href="#L66">66</a><a id="L67" href="#L67">67</a><a id="L68" href="#L68">68</a><a id="L69" href="#L69">69</a><a id="L70" href="#L70">70</a><a id="L71" href="#L71">71</a><a id="L72" href="#L72">72</a><a id="L73" href="#L73">73</a><a id="L74" href="#L74">74</a><a id="L75" href="#L75">75</a><a id="L76" href="#L76">76</a><a id="L77" href="#L77">77</a><a id="L78" href="#L78">78</a><a id="L79" href="#L79">79</a><a id="L80" href="#L80">80</a><a id="L81" href="#L81">81</a><a id="L82" href="#L82">82</a><a id="L83" href="#L83">83</a><a id="L84" href="#L84">84</a><a id="L85" href="#L85">85</a><a id="L86" href="#L86">86</a><a id="L87" href="#L87">87</a><a id="L88" href="#L88">88</a><a id="L89" href="#L89">89</a><a id="L90" href="#L90">90</a><a id="L91" href="#L91">91</a><a id="L92" href="#L92">92</a><a id="L93" href="#L93">93</a><a id="L94" href="#L94">94</a><a id="L95" href="#L95">95</a><a id="L96" href="#L96">96</a><a id="L97" href="#L97">97</a><a id="L98" href="#L98">98</a><a id="L99" href="#L99">99</a><a id="L100" href="#L100">100</a><a id="L101" href="#L101">101</a><a id="L102" href="#L102">102</a><a id="L103" href="#L103">103</a><a id="L104" href="#L104">104</a><a id="L105" href="#L105">105</a><a id="L106" href="#L106">106</a><a id="L107" href="#L107">107</a><a id="L108" href="#L108">108</a><a id="L109" href="#L109">109</a><a id="L110" href="#L110">110</a><a id="L111" href="#L111">111</a><a id="L112" href="#L112">112</a><a id="L113" href="#L113">113</a><a id="L114" href="#L114">114</a><a id="L115" href="#L115">115</a><a id="L116" href="#L116">116</a><a id="L117" href="#L117">117</a><a id="L118" href="#L118">118</a><a id="L119" href="#L119">119</a><a id="L120" href="#L120">120</a><a id="L121" href="#L121">121</a><a id="L122" href="#L122">122</a><a id="L123" href="#L123">123</a><a id="L124" href="#L124">124</a><a id="L125" href="#L125">125</a><a id="L126" href="#L126">126</a><a id="L127" href="#L127">127</a><a id="L128" href="#L128">128</a><a id="L129" href="#L129">129</a><a id="L130" href="#L130">130</a><a id="L131" href="#L131">131</a><a id="L132" href="#L132">132</a><a id="L133" href="#L133">133</a><a id="L134" href="#L134">134</a><a id="L135" href="#L135">135</a><a id="L136" href="#L136">136</a><a id="L137" href="#L137">137</a><a id="L138" href="#L138">138</a><a id="L139" href="#L139">139</a><a id="L140" href="#L140">140</a><a id="L141" href="#L141">141</a><a id="L142" href="#L142">142</a><a id="L143" href="#L143">143</a><a id="L144" href="#L144">144</a><a id="L145" href="#L145">145</a><a id="L146" href="#L146">146</a><a id="L147" href="#L147">147</a><a id="L148" href="#L148">148</a><a id="L149" href="#L149">149</a><a id="L150" href="#L150">150</a><a id="L151" href="#L151">151</a><a id="L152" href="#L152">152</a><a id="L153" href="#L153">153</a><a id="L154" href="#L154">154</a><a id="L155" href="#L155">155</a><a id="L156" href="#L156">156</a><a id="L157" href="#L157">157</a><a id="L158" href="#L158">158</a><a id="L159" href="#L159">159</a><a id="L160" href="#L160">160</a><a id="L161" href="#L161">161</a><a id="L162" href="#L162">162</a><a id="L163" href="#L163">163</a><a id="L164" href="#L164">164</a><a id="L165" href="#L165">165</a><a id="L166" href="#L166">166</a><a id="L167" href="#L167">167</a><a id="L168" href="#L168">168</a><a id="L169" href="#L169">169</a><a id="L170" href="#L170">170</a><a id="L171" href="#L171">171</a><a id="L172" href="#L172">172</a><a id="L173" href="#L173">173</a><a id="L174" href="#L174">174</a><a id="L175" href="#L175">175</a><a id="L176" href="#L176">176</a><a id="L177" href="#L177">177</a><a id="L178" href="#L178">178</a><a id="L179" href="#L179">179</a><a id="L180" href="#L180">180</a><a id="L181" href="#L181">181</a><a id="L182" href="#L182">182</a><a id="L183" href="#L183">183</a><a id="L184" href="#L184">184</a><a id="L185" href="#L185">185</a><a id="L186" href="#L186">186</a><a id="L187" href="#L187">187</a><a id="L188" href="#L188">188</a><a id="L189" href="#L189">189</a><a id="L190" href="#L190">190</a><a id="L191" href="#L191">191</a><a id="L192" href="#L192">192</a><a id="L193" href="#L193">193</a><a id="L194" href="#L194">194</a><a id="L195" href="#L195">195</a><a id="L196" href="#L196">196</a><a id="L197" href="#L197">197</a><a id="L198" href="#L198">198</a><a id="L199" href="#L199">199</a><a id="L200" href="#L200">200</a><a id="L201" href="#L201">201</a><a id="L202" href="#L202">202</a><a id="L203" href="#L203">203</a><a id="L204" href="#L204">204</a><a id="L205" href="#L205">205</a><a id="L206" href="#L206">206</a><a id="L207" href="#L207">207</a><a id="L208" href="#L208">208</a><a id="L209" href="#L209">209</a><a id="L210" href="#L210">210</a><a id="L211" href="#L211">211</a><a id="L212" href="#L212">212</a><a id="L213" href="#L213">213</a><a id="L214" href="#L214">214</a><a id="L215" href="#L215">215</a><a id="L216" href="#L216">216</a><a id="L217" href="#L217">217</a><a id="L218" href="#L218">218</a><a id="L219" href="#L219">219</a><a id="L220" href="#L220">220</a><a id="L221" href="#L221">221</a><a id="L222" href="#L222">222</a><a id="L223" href="#L223">223</a><a id="L224" href="#L224">224</a><a id="L225" href="#L225">225</a><a id="L226" href="#L226">226</a><a id="L227" href="#L227">227</a><a id="L228" href="#L228">228</a><a id="L229" href="#L229">229</a><a id="L230" href="#L230">230</a><a id="L231" href="#L231">231</a><a id="L232" href="#L232">232</a><a id="L233" href="#L233">233</a><a id="L234" href="#L234">234</a><a id="L235" href="#L235">235</a><a id="L236" href="#L236">236</a><a id="L237" href="#L237">237</a><a id="L238" href="#L238">238</a><a id="L239" href="#L239">239</a><a id="L240" href="#L240">240</a><a id="L241" href="#L241">241</a><a id="L242" href="#L242">242</a><a id="L243" href="#L243">243</a><a id="L244" href="#L244">244</a><a id="L245" href="#L245">245</a><a id="L246" href="#L246">246</a><a id="L247" href="#L247">247</a><a id="L248" href="#L248">248</a><a id="L249" href="#L249">249</a><a id="L250" href="#L250">250</a><a id="L251" href="#L251">251</a><a id="L252" href="#L252">252</a><a id="L253" href="#L253">253</a><a id="L254" href="#L254">254</a><a id="L255" href="#L255">255</a><a id="L256" href="#L256">256</a><a id="L257" href="#L257">257</a><a id="L258" href="#L258">258</a><a id="L259" href="#L259">259</a><a id="L260" href="#L260">260</a><a id="L261" href="#L261">261</a><a id="L262" href="#L262">262</a><a id="L263" href="#L263">263</a><a id="L264" href="#L264">264</a><a id="L265" href="#L265">265</a><a id="L266" href="#L266">266</a><a id="L267" href="#L267">267</a><a id="L268" href="#L268">268</a><a id="L269" href="#L269">269</a><a id="L270" href="#L270">270</a><a id="L271" href="#L271">271</a><a id="L272" href="#L272">272</a><a id="L273" href="#L273">273</a><a id="L274" href="#L274">274</a><a id="L275" href="#L275">275</a><a id="L276" href="#L276">276</a><a id="L277" href="#L277">277</a><a id="L278" href="#L278">278</a><a id="L279" href="#L279">279</a><a id="L280" href="#L280">280</a><a id="L281" href="#L281">281</a><a id="L282" href="#L282">282</a><a id="L283" href="#L283">283</a><a id="L284" href="#L284">284</a><a id="L285" href="#L285">285</a><a id="L286" href="#L286">286</a><a id="L287" href="#L287">287</a><a id="L288" href="#L288">288</a><a id="L289" href="#L289">289</a><a id="L290" href="#L290">290</a><a id="L291" href="#L291">291</a><a id="L292" href="#L292">292</a><a id="L293" href="#L293">293</a><a id="L294" href="#L294">294</a><a id="L295" href="#L295">295</a><a id="L296" href="#L296">296</a><a id="L297" href="#L297">297</a><a id="L298" href="#L298">298</a><a id="L299" href="#L299">299</a><a id="L300" href="#L300">300</a><a id="L301" href="#L301">301</a><a id="L302" href="#L302">302</a><a id="L303" href="#L303">303</a><a id="L304" href="#L304">304</a><a id="L305" href="#L305">305</a><a id="L306" href="#L306">306</a><a id="L307" href="#L307">307</a><a id="L308" href="#L308">308</a><a id="L309" href="#L309">309</a><a id="L310" href="#L310">310</a><a id="L311" href="#L311">311</a><a id="L312" href="#L312">312</a><a id="L313" href="#L313">313</a><a id="L314" href="#L314">314</a><a id="L315" href="#L315">315</a><a id="L316" href="#L316">316</a><a id="L317" href="#L317">317</a><a id="L318" href="#L318">318</a><a id="L319" href="#L319">319</a><a id="L320" href="#L320">320</a><a id="L321" href="#L321">321</a><a id="L322" href="#L322">322</a><a id="L323" href="#L323">323</a><a id="L324" href="#L324">324</a><a id="L325" href="#L325">325</a><a id="L326" href="#L326">326</a><a id="L327" href="#L327">327</a><a id="L328" href="#L328">328</a><a id="L329" href="#L329">329</a><a id="L330" href="#L330">330</a><a id="L331" href="#L331">331</a><a id="L332" href="#L332">332</a><a id="L333" href="#L333">333</a><a id="L334" href="#L334">334</a><a id="L335" href="#L335">335</a><a id="L336" href="#L336">336</a><a id="L337" href="#L337">337</a><a id="L338" href="#L338">338</a><a id="L339" href="#L339">339</a><a id="L340" href="#L340">340</a><a id="L341" href="#L341">341</a><a id="L342" href="#L342">342</a><a id="L343" href="#L343">343</a><a id="L344" href="#L344">344</a><a id="L345" href="#L345">345</a><a id="L346" href="#L346">346</a><a id="L347" href="#L347">347</a><a id="L348" href="#L348">348</a><a id="L349" href="#L349">349</a><a id="L350" href="#L350">350</a><a id="L351" href="#L351">351</a><a id="L352" href="#L352">352</a><a id="L353" href="#L353">353</a><a id="L354" href="#L354">354</a><a id="L355" href="#L355">355</a><a id="L356" href="#L356">356</a><a id="L357" href="#L357">357</a><a id="L358" href="#L358">358</a><a id="L359" href="#L359">359</a><a id="L360" href="#L360">360</a><a id="L361" href="#L361">361</a><a id="L362" href="#L362">362</a><a id="L363" href="#L363">363</a><a id="L364" href="#L364">364</a><a id="L365" href="#L365">365</a><a id="L366" href="#L366">366</a><a id="L367" href="#L367">367</a><a id="L368" href="#L368">368</a><a id="L369" href="#L369">369</a><a id="L370" href="#L370">370</a><a id="L371" href="#L371">371</a><a id="L372" href="#L372">372</a><a id="L373" href="#L373">373</a><a id="L374" href="#L374">374</a><a id="L375" href="#L375">375</a><a id="L376" href="#L376">376</a><a id="L377" href="#L377">377</a><a id="L378" href="#L378">378</a><a id="L379" href="#L379">379</a><a id="L380" href="#L380">380</a><a id="L381" href="#L381">381</a><a id="L382" href="#L382">382</a><a id="L383" href="#L383">383</a><a id="L384" href="#L384">384</a><a id="L385" href="#L385">385</a><a id="L386" href="#L386">386</a><a id="L387" href="#L387">387</a><a id="L388" href="#L388">388</a><a id="L389" href="#L389">389</a><a id="L390" href="#L390">390</a><a id="L391" href="#L391">391</a><a id="L392" href="#L392">392</a><a id="L393" href="#L393">393</a><a id="L394" href="#L394">394</a><a id="L395" href="#L395">395</a><a id="L396" href="#L396">396</a><a id="L397" href="#L397">397</a><a id="L398" href="#L398">398</a><a id="L399" href="#L399">399</a><a id="L400" href="#L400">400</a><a id="L401" href="#L401">401</a><a id="L402" href="#L402">402</a><a id="L403" href="#L403">403</a><a id="L404" href="#L404">404</a><a id="L405" href="#L405">405</a><a id="L406" href="#L406">406</a><a id="L407" href="#L407">407</a><a id="L408" href="#L408">408</a><a id="L409" href="#L409">409</a><a id="L410" href="#L410">410</a><a id="L411" href="#L411">411</a><a id="L412" href="#L412">412</a><a id="L413" href="#L413">413</a><a id="L414" href="#L414">414</a><a id="L415" href="#L415">415</a><a id="L416" href="#L416">416</a><a id="L417" href="#L417">417</a><a id="L418" href="#L418">418</a><a id="L419" href="#L419">419</a><a id="L420" href="#L420">420</a><a id="L421" href="#L421">421</a><a id="L422" href="#L422">422</a><a id="L423" href="#L423">423</a><a id="L424" href="#L424">424</a><a id="L425" href="#L425">425</a><a id="L426" href="#L426">426</a><a id="L427" href="#L427">427</a><a id="L428" href="#L428">428</a><a id="L429" href="#L429">429</a><a id="L430" href="#L430">430</a><a id="L431" href="#L431">431</a><a id="L432" href="#L432">432</a><a id="L433" href="#L433">433</a><a id="L434" href="#L434">434</a><a id="L435" href="#L435">435</a><a id="L436" href="#L436">436</a><a id="L437" href="#L437">437</a><a id="L438" href="#L438">438</a><a id="L439" href="#L439">439</a><a id="L440" href="#L440">440</a><a id="L441" href="#L441">441</a><a id="L442" href="#L442">442</a><a id="L443" href="#L443">443</a><a id="L444" href="#L444">444</a><a id="L445" href="#L445">445</a><a id="L446" href="#L446">446</a><a id="L447" href="#L447">447</a><a id="L448" href="#L448">448</a><a id="L449" href="#L449">449</a><a id="L450" href="#L450">450</a><a id="L451" href="#L451">451</a><a id="L452" href="#L452">452</a><a id="L453" href="#L453">453</a><a id="L454" href="#L454">454</a><a id="L455" href="#L455">455</a><a id="L456" href="#L456">456</a><a id="L457" href="#L457">457</a><a id="L458" href="#L458">458</a><a id="L459" href="#L459">459</a><a id="L460" href="#L460">460</a><a id="L461" href="#L461">461</a><a id="L462" href="#L462">462</a><a id="L463" href="#L463">463</a><a id="L464" href="#L464">464</a><a id="L465" href="#L465">465</a><a id="L466" href="#L466">466</a><a id="L467" href="#L467">467</a><a id="L468" href="#L468">468</a><a id="L469" href="#L469">469</a><a id="L470" href="#L470">470</a><a id="L471" href="#L471">471</a><a id="L472" href="#L472">472</a><a id="L473" href="#L473">473</a><a id="L474" href="#L474">474</a><a id="L475" href="#L475">475</a><a id="L476" href="#L476">476</a><a id="L477" href="#L477">477</a><a id="L478" href="#L478">478</a><a id="L479" href="#L479">479</a><a id="L480" href="#L480">480</a><a id="L481" href="#L481">481</a><a id="L482" href="#L482">482</a><a id="L483" href="#L483">483</a><a id="L484" href="#L484">484</a><a id="L485" href="#L485">485</a><a id="L486" href="#L486">486</a><a id="L487" href="#L487">487</a><a id="L488" href="#L488">488</a><a id="L489" href="#L489">489</a><a id="L490" href="#L490">490</a><a id="L491" href="#L491">491</a><a id="L492" href="#L492">492</a><a id="L493" href="#L493">493</a><a id="L494" href="#L494">494</a><a id="L495" href="#L495">495</a><a id="L496" href="#L496">496</a><a id="L497" href="#L497">497</a><a id="L498" href="#L498">498</a><a id="L499" href="#L499">499</a><a id="L500" href="#L500">500</a><a id="L501" href="#L501">501</a><a id="L502" href="#L502">502</a><a id="L503" href="#L503">503</a><a id="L504" href="#L504">504</a><a id="L505" href="#L505">505</a><a id="L506" href="#L506">506</a><a id="L507" href="#L507">507</a><a id="L508" href="#L508">508</a><a id="L509" href="#L509">509</a><a id="L510" href="#L510">510</a><a id="L511" href="#L511">511</a><a id="L512" href="#L512">512</a><a id="L513" href="#L513">513</a><a id="L514" href="#L514">514</a><a id="L515" href="#L515">515</a><a id="L516" href="#L516">516</a><a id="L517" href="#L517">517</a><a id="L518" href="#L518">518</a><a id="L519" href="#L519">519</a><a id="L520" href="#L520">520</a><a id="L521" href="#L521">521</a><a id="L522" href="#L522">522</a><a id="L523" href="#L523">523</a><a id="L524" href="#L524">524</a><a id="L525" href="#L525">525</a><a id="L526" href="#L526">526</a><a id="L527" href="#L527">527</a><a id="L528" href="#L528">528</a><a id="L529" href="#L529">529</a><a id="L530" href="#L530">530</a><a id="L531" href="#L531">531</a><a id="L532" href="#L532">532</a><a id="L533" href="#L533">533</a><a id="L534" href="#L534">534</a><a id="L535" href="#L535">535</a><a id="L536" href="#L536">536</a><a id="L537" href="#L537">537</a><a id="L538" href="#L538">538</a><a id="L539" href="#L539">539</a><a id="L540" href="#L540">540</a><a id="L541" href="#L541">541</a><a id="L542" href="#L542">542</a><a id="L543" href="#L543">543</a><a id="L544" href="#L544">544</a><a id="L545" href="#L545">545</a><a id="L546" href="#L546">546</a><a id="L547" href="#L547">547</a><a id="L548" href="#L548">548</a><a id="L549" href="#L549">549</a><a id="L550" href="#L550">550</a><a id="L551" href="#L551">551</a><a id="L552" href="#L552">552</a><a id="L553" href="#L553">553</a><a id="L554" href="#L554">554</a><a id="L555" href="#L555">555</a><a id="L556" href="#L556">556</a><a id="L557" href="#L557">557</a><a id="L558" href="#L558">558</a><a id="L559" href="#L559">559</a><a id="L560" href="#L560">560</a><a id="L561" href="#L561">561</a><a id="L562" href="#L562">562</a><a id="L563" href="#L563">563</a><a id="L564" href="#L564">564</a><a id="L565" href="#L565">565</a><a id="L566" href="#L566">566</a><a id="L567" href="#L567">567</a><a id="L568" href="#L568">568</a><a id="L569" href="#L569">569</a><a id="L570" href="#L570">570</a><a id="L571" href="#L571">571</a><a id="L572" href="#L572">572</a><a id="L573" href="#L573">573</a><a id="L574" href="#L574">574</a><a id="L575" href="#L575">575</a><a id="L576" href="#L576">576</a><a id="L577" href="#L577">577</a><a id="L578" href="#L578">578</a><a id="L579" href="#L579">579</a><a id="L580" href="#L580">580</a><a id="L581" href="#L581">581</a><a id="L582" href="#L582">582</a><a id="L583" href="#L583">583</a><a id="L584" href="#L584">584</a><a id="L585" href="#L585">585</a><a id="L586" href="#L586">586</a><a id="L587" href="#L587">587</a><a id="L588" href="#L588">588</a><a id="L589" href="#L589">589</a><a id="L590" href="#L590">590</a><a id="L591" href="#L591">591</a><a id="L592" href="#L592">592</a><a id="L593" href="#L593">593</a><a id="L594" href="#L594">594</a><a id="L595" href="#L595">595</a><a id="L596" href="#L596">596</a><a id="L597" href="#L597">597</a><a id="L598" href="#L598">598</a><a id="L599" href="#L599">599</a><a id="L600" href="#L600">600</a><a id="L601" href="#L601">601</a><a id="L602" href="#L602">602</a><a id="L603" href="#L603">603</a><a id="L604" href="#L604">604</a><a id="L605" href="#L605">605</a><a id="L606" href="#L606">606</a><a id="L607" href="#L607">607</a><a id="L608" href="#L608">608</a><a id="L609" href="#L609">609</a><a id="L610" href="#L610">610</a><a id="L611" href="#L611">611</a><a id="L612" href="#L612">612</a><a id="L613" href="#L613">613</a><a id="L614" href="#L614">614</a><a id="L615" href="#L615">615</a><a id="L616" href="#L616">616</a><a id="L617" href="#L617">617</a><a id="L618" href="#L618">618</a><a id="L619" href="#L619">619</a><a id="L620" href="#L620">620</a><a id="L621" href="#L621">621</a><a id="L622" href="#L622">622</a><a id="L623" href="#L623">623</a><a id="L624" href="#L624">624</a><a id="L625" href="#L625">625</a><a id="L626" href="#L626">626</a><a id="L627" href="#L627">627</a><a id="L628" href="#L628">628</a><a id="L629" href="#L629">629</a><a id="L630" href="#L630">630</a><a id="L631" href="#L631">631</a><a id="L632" href="#L632">632</a><a id="L633" href="#L633">633</a><a id="L634" href="#L634">634</a><a id="L635" href="#L635">635</a><a id="L636" href="#L636">636</a><a id="L637" href="#L637">637</a><a id="L638" href="#L638">638</a><a id="L639" href="#L639">639</a><a id="L640" href="#L640">640</a><a id="L641" href="#L641">641</a><a id="L642" href="#L642">642</a><a id="L643" href="#L643">643</a><a id="L644" href="#L644">644</a><a id="L645" href="#L645">645</a><a id="L646" href="#L646">646</a><a id="L647" href="#L647">647</a><a id="L648" href="#L648">648</a><a id="L649" href="#L649">649</a><a id="L650" href="#L650">650</a><a id="L651" href="#L651">651</a><a id="L652" href="#L652">652</a><a id="L653" href="#L653">653</a><a id="L654" href="#L654">654</a><a id="L655" href="#L655">655</a><a id="L656" href="#L656">656</a><a id="L657" href="#L657">657</a><a id="L658" href="#L658">658</a><a id="L659" href="#L659">659</a><a id="L660" href="#L660">660</a><a id="L661" href="#L661">661</a><a id="L662" href="#L662">662</a><a id="L663" href="#L663">663</a><a id="L664" href="#L664">664</a><a id="L665" href="#L665">665</a><a id="L666" href="#L666">666</a><a id="L667" href="#L667">667</a><a id="L668" href="#L668">668</a><a id="L669" href="#L669">669</a><a id="L670" href="#L670">670</a><a id="L671" href="#L671">671</a><a id="L672" href="#L672">672</a><a id="L673" href="#L673">673</a><a id="L674" href="#L674">674</a><a id="L675" href="#L675">675</a><a id="L676" href="#L676">676</a><a id="L677" href="#L677">677</a><a id="L678" href="#L678">678</a><a id="L679" href="#L679">679</a><a id="L680" href="#L680">680</a><a id="L681" href="#L681">681</a><a id="L682" href="#L682">682</a><a id="L683" href="#L683">683</a><a id="L684" href="#L684">684</a><a id="L685" href="#L685">685</a><a id="L686" href="#L686">686</a><a id="L687" href="#L687">687</a><a id="L688" href="#L688">688</a><a id="L689" href="#L689">689</a><a id="L690" href="#L690">690</a><a id="L691" href="#L691">691</a><a id="L692" href="#L692">692</a><a id="L693" href="#L693">693</a><a id="L694" href="#L694">694</a><a id="L695" href="#L695">695</a><a id="L696" href="#L696">696</a><a id="L697" href="#L697">697</a><a id="L698" href="#L698">698</a><a id="L699" href="#L699">699</a><a id="L700" href="#L700">700</a><a id="L701" href="#L701">701</a><a id="L702" href="#L702">702</a><a id="L703" href="#L703">703</a><a id="L704" href="#L704">704</a><a id="L705" href="#L705">705</a><a id="L706" href="#L706">706</a><a id="L707" href="#L707">707</a><a id="L708" href="#L708">708</a><a id="L709" href="#L709">709</a><a id="L710" href="#L710">710</a><a id="L711" href="#L711">711</a><a id="L712" href="#L712">712</a><a id="L713" href="#L713">713</a><a id="L714" href="#L714">714</a><a id="L715" href="#L715">715</a><a id="L716" href="#L716">716</a><a id="L717" href="#L717">717</a><a id="L718" href="#L718">718</a><a id="L719" href="#L719">719</a><a id="L720" href="#L720">720</a><a id="L721" href="#L721">721</a><a id="L722" href="#L722">722</a><a id="L723" href="#L723">723</a><a id="L724" href="#L724">724</a><a id="L725" href="#L725">725</a><a id="L726" href="#L726">726</a><a id="L727" href="#L727">727</a><a id="L728" href="#L728">728</a><a id="L729" href="#L729">729</a><a id="L730" href="#L730">730</a><a id="L731" href="#L731">731</a><a id="L732" href="#L732">732</a><a id="L733" href="#L733">733</a><a id="L734" href="#L734">734</a><a id="L735" href="#L735">735</a><a id="L736" href="#L736">736</a><a id="L737" href="#L737">737</a><a id="L738" href="#L738">738</a><a id="L739" href="#L739">739</a><a id="L740" href="#L740">740</a><a id="L741" href="#L741">741</a><a id="L742" href="#L742">742</a><a id="L743" href="#L743">743</a><a id="L744" href="#L744">744</a><a id="L745" href="#L745">745</a><a id="L746" href="#L746">746</a><a id="L747" href="#L747">747</a><a id="L748" href="#L748">748</a><a id="L749" href="#L749">749</a><a id="L750" href="#L750">750</a><a id="L751" href="#L751">751</a><a id="L752" href="#L752">752</a><a id="L753" href="#L753">753</a><a id="L754" href="#L754">754</a><a id="L755" href="#L755">755</a><a id="L756" href="#L756">756</a><a id="L757" href="#L757">757</a><a id="L758" href="#L758">758</a><a id="L759" href="#L759">759</a><a id="L760" href="#L760">760</a><a id="L761" href="#L761">761</a><a id="L762" href="#L762">762</a><a id="L763" href="#L763">763</a><a id="L764" href="#L764">764</a><a id="L765" href="#L765">765</a><a id="L766" href="#L766">766</a><a id="L767" href="#L767">767</a><a id="L768" href="#L768">768</a><a id="L769" href="#L769">769</a><a id="L770" href="#L770">770</a><a id="L771" href="#L771">771</a><a id="L772" href="#L772">772</a><a id="L773" href="#L773">773</a><a id="L774" href="#L774">774</a><a id="L775" href="#L775">775</a><a id="L776" href="#L776">776</a><a id="L777" href="#L777">777</a><a id="L778" href="#L778">778</a><a id="L779" href="#L779">779</a><a id="L780" href="#L780">780</a><a id="L781" href="#L781">781</a><a id="L782" href="#L782">782</a><a id="L783" href="#L783">783</a><a id="L784" href="#L784">784</a><a id="L785" href="#L785">785</a><a id="L786" href="#L786">786</a><a id="L787" href="#L787">787</a><a id="L788" href="#L788">788</a><a id="L789" href="#L789">789</a><a id="L790" href="#L790">790</a><a id="L791" href="#L791">791</a><a id="L792" href="#L792">792</a><a id="L793" href="#L793">793</a><a id="L794" href="#L794">794</a><a id="L795" href="#L795">795</a><a id="L796" href="#L796">796</a><a id="L797" href="#L797">797</a><a id="L798" href="#L798">798</a><a id="L799" href="#L799">799</a><a id="L800" href="#L800">800</a><a id="L801" href="#L801">801</a><a id="L802" href="#L802">802</a><a id="L803" href="#L803">803</a><a id="L804" href="#L804">804</a><a id="L805" href="#L805">805</a><a id="L806" href="#L806">806</a><a id="L807" href="#L807">807</a><a id="L808" href="#L808">808</a><a id="L809" href="#L809">809</a><a id="L810" href="#L810">810</a><a id="L811" href="#L811">811</a><a id="L812" href="#L812">812</a><a id="L813" href="#L813">813</a><a id="L814" href="#L814">814</a><a id="L815" href="#L815">815</a><a id="L816" href="#L816">816</a><a id="L817" href="#L817">817</a><a id="L818" href="#L818">818</a><a id="L819" href="#L819">819</a><a id="L820" href="#L820">820</a><a id="L821" href="#L821">821</a><a id="L822" href="#L822">822</a><a id="L823" href="#L823">823</a><a id="L824" href="#L824">824</a><a id="L825" href="#L825">825</a><a id="L826" href="#L826">826</a><a id="L827" href="#L827">827</a><a id="L828" href="#L828">828</a><a id="L829" href="#L829">829</a><a id="L830" href="#L830">830</a><a id="L831" href="#L831">831</a><a id="L832" href="#L832">832</a><a id="L833" href="#L833">833</a><a id="L834" href="#L834">834</a><a id="L835" href="#L835">835</a><a id="L836" href="#L836">836</a><a id="L837" href="#L837">837</a><a id="L838" href="#L838">838</a><a id="L839" href="#L839">839</a><a id="L840" href="#L840">840</a><a id="L841" href="#L841">841</a><a id="L842" href="#L842">842</a><a id="L843" href="#L843">843</a><a id="L844" href="#L844">844</a><a id="L845" href="#L845">845</a><a id="L846" href="#L846">846</a><a id="L847" href="#L847">847</a><a id="L848" href="#L848">848</a><a id="L849" href="#L849">849</a><a id="L850" href="#L850">850</a><a id="L851" href="#L851">851</a><a id="L852" href="#L852">852</a><a id="L853" href="#L853">853</a><a id="L854" href="#L854">854</a><a id="L855" href="#L855">855</a><a id="L856" href="#L856">856</a><a id="L857" href="#L857">857</a><a id="L858" href="#L858">858</a><a id="L859" href="#L859">859</a><a id="L860" href="#L860">860</a><a id="L861" href="#L861">861</a><a id="L862" href="#L862">862</a><a id="L863" href="#L863">863</a><a id="L864" href="#L864">864</a><a id="L865" href="#L865">865</a><a id="L866" href="#L866">866</a><a id="L867" href="#L867">867</a><a id="L868" href="#L868">868</a><a id="L869" href="#L869">869</a><a id="L870" href="#L870">870</a><a id="L871" href="#L871">871</a><a id="L872" href="#L872">872</a><a id="L873" href="#L873">873</a><a id="L874" href="#L874">874</a><a id="L875" href="#L875">875</a><a id="L876" href="#L876">876</a><a id="L877" href="#L877">877</a><a id="L878" href="#L878">878</a><a id="L879" href="#L879">879</a><a id="L880" href="#L880">880</a><a id="L881" href="#L881">881</a><a id="L882" href="#L882">882</a><a id="L883" href="#L883">883</a><a id="L884" href="#L884">884</a><a id="L885" href="#L885">885</a><a id="L886" href="#L886">886</a><a id="L887" href="#L887">887</a><a id="L888" href="#L888">888</a><a id="L889" href="#L889">889</a><a id="L890" href="#L890">890</a><a id="L891" href="#L891">891</a><a id="L892" href="#L892">892</a><a id="L893" href="#L893">893</a><a id="L894" href="#L894">894</a><a id="L895" href="#L895">895</a><a id="L896" href="#L896">896</a><a id="L897" href="#L897">897</a><a id="L898" href="#L898">898</a><a id="L899" href="#L899">899</a><a id="L900" href="#L900">900</a><a id="L901" href="#L901">901</a><a id="L902" href="#L902">902</a><a id="L903" href="#L903">903</a><a id="L904" href="#L904">904</a><a id="L905" href="#L905">905</a><a id="L906" href="#L906">906</a><a id="L907" href="#L907">907</a><a id="L908" href="#L908">908</a><a id="L909" href="#L909">909</a><a id="L910" href="#L910">910</a><a id="L911" href="#L911">911</a><a id="L912" href="#L912">912</a><a id="L913" href="#L913">913</a><a id="L914" href="#L914">914</a><a id="L915" href="#L915">915</a><a id="L916" href="#L916">916</a><a id="L917" href="#L917">917</a><a id="L918" href="#L918">918</a><a id="L919" href="#L919">919</a><a id="L920" href="#L920">920</a><a id="L921" href="#L921">921</a><a id="L922" href="#L922">922</a><a id="L923" href="#L923">923</a><a id="L924" href="#L924">924</a><a id="L925" href="#L925">925</a><a id="L926" href="#L926">926</a><a id="L927" href="#L927">927</a><a id="L928" href="#L928">928</a><a id="L929" href="#L929">929</a><a id="L930" href="#L930">930</a><a id="L931" href="#L931">931</a><a id="L932" href="#L932">932</a><a id="L933" href="#L933">933</a><a id="L934" href="#L934">934</a><a id="L935" href="#L935">935</a><a id="L936" href="#L936">936</a><a id="L937" href="#L937">937</a><a id="L938" href="#L938">938</a><a id="L939" href="#L939">939</a><a id="L940" href="#L940">940</a><a id="L941" href="#L941">941</a><a id="L942" href="#L942">942</a><a id="L943" href="#L943">943</a><a id="L944" href="#L944">944</a><a id="L945" href="#L945">945</a><a id="L946" href="#L946">946</a><a id="L947" href="#L947">947</a><a id="L948" href="#L948">948</a><a id="L949" href="#L949">949</a><a id="L950" href="#L950">950</a><a id="L951" href="#L951">951</a><a id="L952" href="#L952">952</a><a id="L953" href="#L953">953</a><a id="L954" href="#L954">954</a><a id="L955" href="#L955">955</a><a id="L956" href="#L956">956</a><a id="L957" href="#L957">957</a><a id="L958" href="#L958">958</a><a id="L959" href="#L959">959</a><a id="L960" href="#L960">960</a><a id="L961" href="#L961">961</a><a id="L962" href="#L962">962</a><a id="L963" href="#L963">963</a><a id="L964" href="#L964">964</a><a id="L965" href="#L965">965</a><a id="L966" href="#L966">966</a><a id="L967" href="#L967">967</a><a id="L968" href="#L968">968</a><a id="L969" href="#L969">969</a><a id="L970" href="#L970">970</a><a id="L971" href="#L971">971</a><a id="L972" href="#L972">972</a><a id="L973" href="#L973">973</a><a id="L974" href="#L974">974</a><a id="L975" href="#L975">975</a><a id="L976" href="#L976">976</a><a id="L977" href="#L977">977</a><a id="L978" href="#L978">978</a><a id="L979" href="#L979">979</a><a id="L980" href="#L980">980</a><a id="L981" href="#L981">981</a><a id="L982" href="#L982">982</a><a id="L983" href="#L983">983</a><a id="L984" href="#L984">984</a><a id="L985" href="#L985">985</a><a id="L986" href="#L986">986</a><a id="L987" href="#L987">987</a><a id="L988" href="#L988">988</a><a id="L989" href="#L989">989</a><a id="L990" href="#L990">990</a><a id="L991" href="#L991">991</a><a id="L992" href="#L992">992</a><a id="L993" href="#L993">993</a><a id="L994" href="#L994">994</a><a id="L995" href="#L995">995</a><a id="L996" href="#L996">996</a><a id="L997" href="#L997">997</a><a id="L998" href="#L998">998</a><a id="L999" href="#L999">999</a><a id="L1000" href="#L1000">1000</a><a id="L1001" href="#L1001">1001</a><a id="L1002" href="#L1002">1002</a><a id="L1003" href="#L1003">1003</a><a id="L1004" href="#L1004">1004</a><a id="L1005" href="#L1005">1005</a><a id="L1006" href="#L1006">1006</a><a id="L1007" href="#L1007">1007</a><a id="L1008" href="#L1008">1008</a><a id="L1009" href="#L1009">1009</a><a id="L1010" href="#L1010">1010</a><a id="L1011" href="#L1011">1011</a><a id="L1012" href="#L1012">1012</a><a id="L1013" href="#L1013">1013</a><a id="L1014" href="#L1014">1014</a><a id="L1015" href="#L1015">1015</a><a id="L1016" href="#L1016">1016</a><a id="L1017" href="#L1017">1017</a><a id="L1018" href="#L1018">1018</a><a id="L1019" href="#L1019">1019</a><a id="L1020" href="#L1020">1020</a><a id="L1021" href="#L1021">1021</a><a id="L1022" href="#L1022">1022</a><a id="L1023" href="#L1023">1023</a><a id="L1024" href="#L1024">1024</a><a id="L1025" href="#L1025">1025</a><a id="L1026" href="#L1026">1026</a><a id="L1027" href="#L1027">1027</a><a id="L1028" href="#L1028">1028</a><a id="L1029" href="#L1029">1029</a><a id="L1030" href="#L1030">1030</a><a id="L1031" href="#L1031">1031</a><a id="L1032" href="#L1032">1032</a><a id="L1033" href="#L1033">1033</a><a id="L1034" href="#L1034">1034</a><a id="L1035" href="#L1035">1035</a><a id="L1036" href="#L1036">1036</a><a id="L1037" href="#L1037">1037</a><a id="L1038" href="#L1038">1038</a><a id="L1039" href="#L1039">1039</a><a id="L1040" href="#L1040">1040</a><a id="L1041" href="#L1041">1041</a><a id="L1042" href="#L1042">1042</a><a id="L1043" href="#L1043">1043</a><a id="L1044" href="#L1044">1044</a><a id="L1045" href="#L1045">1045</a><a id="L1046" href="#L1046">1046</a><a id="L1047" href="#L1047">1047</a><a id="L1048" href="#L1048">1048</a><a id="L1049" href="#L1049">1049</a><a id="L1050" href="#L1050">1050</a><a id="L1051" href="#L1051">1051</a><a id="L1052" href="#L1052">1052</a><a id="L1053" href="#L1053">1053</a><a id="L1054" href="#L1054">1054</a><a id="L1055" href="#L1055">1055</a><a id="L1056" href="#L1056">1056</a><a id="L1057" href="#L1057">1057</a><a id="L1058" href="#L1058">1058</a><a id="L1059" href="#L1059">1059</a><a id="L1060" href="#L1060">1060</a><a id="L1061" href="#L1061">1061</a><a id="L1062" href="#L1062">1062</a><a id="L1063" href="#L1063">1063</a><a id="L1064" href="#L1064">1064</a><a id="L1065" href="#L1065">1065</a><a id="L1066" href="#L1066">1066</a><a id="L1067" href="#L1067">1067</a><a id="L1068" href="#L1068">1068</a><a id="L1069" href="#L1069">1069</a><a id="L1070" href="#L1070">1070</a><a id="L1071" href="#L1071">1071</a><a id="L1072" href="#L1072">1072</a><a id="L1073" href="#L1073">1073</a><a id="L1074" href="#L1074">1074</a><a id="L1075" href="#L1075">1075</a><a id="L1076" href="#L1076">1076</a><a id="L1077" href="#L1077">1077</a><a id="L1078" href="#L1078">1078</a><a id="L1079" href="#L1079">1079</a><a id="L1080" href="#L1080">1080</a><a id="L1081" href="#L1081">1081</a><a id="L1082" href="#L1082">1082</a><a id="L1083" href="#L1083">1083</a><a id="L1084" href="#L1084">1084</a><a id="L1085" href="#L1085">1085</a><a id="L1086" href="#L1086">1086</a><a id="L1087" href="#L1087">1087</a><a id="L1088" href="#L1088">1088</a><a id="L1089" href="#L1089">1089</a><a id="L1090" href="#L1090">1090</a><a id="L1091" href="#L1091">1091</a><a id="L1092" href="#L1092">1092</a><a id="L1093" href="#L1093">1093</a><a id="L1094" href="#L1094">1094</a><a id="L1095" href="#L1095">1095</a><a id="L1096" href="#L1096">1096</a><a id="L1097" href="#L1097">1097</a><a id="L1098" href="#L1098">1098</a><a id="L1099" href="#L1099">1099</a><a id="L1100" href="#L1100">1100</a><a id="L1101" href="#L1101">1101</a><a id="L1102" href="#L1102">1102</a><a id="L1103" href="#L1103">1103</a><a id="L1104" href="#L1104">1104</a><a id="L1105" href="#L1105">1105</a><a id="L1106" href="#L1106">1106</a><a id="L1107" href="#L1107">1107</a><a id="L1108" href="#L1108">1108</a><a id="L1109" href="#L1109">1109</a><a id="L1110" href="#L1110">1110</a><a id="L1111" href="#L1111">1111</a><a id="L1112" href="#L1112">1112</a><a id="L1113" href="#L1113">1113</a><a id="L1114" href="#L1114">1114</a><a id="L1115" href="#L1115">1115</a><a id="L1116" href="#L1116">1116</a><a id="L1117" href="#L1117">1117</a><a id="L1118" href="#L1118">1118</a><a id="L1119" href="#L1119">1119</a><a id="L1120" href="#L1120">1120</a><a id="L1121" href="#L1121">1121</a><a id="L1122" href="#L1122">1122</a><a id="L1123" href="#L1123">1123</a><a id="L1124" href="#L1124">1124</a><a id="L1125" href="#L1125">1125</a><a id="L1126" href="#L1126">1126</a><a id="L1127" href="#L1127">1127</a><a id="L1128" href="#L1128">1128</a><a id="L1129" href="#L1129">1129</a><a id="L1130" href="#L1130">1130</a><a id="L1131" href="#L1131">1131</a><a id="L1132" href="#L1132">1132</a><a id="L1133" href="#L1133">1133</a><a id="L1134" href="#L1134">1134</a><a id="L1135" href="#L1135">1135</a><a id="L1136" href="#L1136">1136</a><a id="L1137" href="#L1137">1137</a><a id="L1138" href="#L1138">1138</a><a id="L1139" href="#L1139">1139</a><a id="L1140" href="#L1140">1140</a><a id="L1141" href="#L1141">1141</a><a id="L1142" href="#L1142">1142</a><a id="L1143" href="#L1143">1143</a><a id="L1144" href="#L1144">1144</a><a id="L1145" href="#L1145">1145</a><a id="L1146" href="#L1146">1146</a><a id="L1147" href="#L1147">1147</a><a id="L1148" href="#L1148">1148</a><a id="L1149" href="#L1149">1149</a><a id="L1150" href="#L1150">1150</a><a id="L1151" href="#L1151">1151</a><a id="L1152" href="#L1152">1152</a><a id="L1153" href="#L1153">1153</a><a id="L1154" href="#L1154">1154</a><a id="L1155" href="#L1155">1155</a><a id="L1156" href="#L1156">1156</a><a id="L1157" href="#L1157">1157</a><a id="L1158" href="#L1158">1158</a><a id="L1159" href="#L1159">1159</a><a id="L1160" href="#L1160">1160</a><a id="L1161" href="#L1161">1161</a><a id="L1162" href="#L1162">1162</a><a id="L1163" href="#L1163">1163</a><a id="L1164" href="#L1164">1164</a><a id="L1165" href="#L1165">1165</a><a id="L1166" href="#L1166">1166</a><a id="L1167" href="#L1167">1167</a><a id="L1168" href="#L1168">1168</a><a id="L1169" href="#L1169">1169</a><a id="L1170" href="#L1170">1170</a><a id="L1171" href="#L1171">1171</a><a id="L1172" href="#L1172">1172</a><a id="L1173" href="#L1173">1173</a><a id="L1174" href="#L1174">1174</a><a id="L1175" href="#L1175">1175</a><a id="L1176" href="#L1176">1176</a><a id="L1177" href="#L1177">1177</a><a id="L1178" href="#L1178">1178</a><a id="L1179" href="#L1179">1179</a><a id="L1180" href="#L1180">1180</a><a id="L1181" href="#L1181">1181</a><a id="L1182" href="#L1182">1182</a><a id="L1183" href="#L1183">1183</a><a id="L1184" href="#L1184">1184</a><a id="L1185" href="#L1185">1185</a><a id="L1186" href="#L1186">1186</a><a id="L1187" href="#L1187">1187</a><a id="L1188" href="#L1188">1188</a><a id="L1189" href="#L1189">1189</a><a id="L1190" href="#L1190">1190</a><a id="L1191" href="#L1191">1191</a><a id="L1192" href="#L1192">1192</a><a id="L1193" href="#L1193">1193</a><a id="L1194" href="#L1194">1194</a><a id="L1195" href="#L1195">1195</a><a id="L1196" href="#L1196">1196</a><a id="L1197" href="#L1197">1197</a><a id="L1198" href="#L1198">1198</a><a id="L1199" href="#L1199">1199</a><a id="L1200" href="#L1200">1200</a><a id="L1201" href="#L1201">1201</a><a id="L1202" href="#L1202">1202</a><a id="L1203" href="#L1203">1203</a><a id="L1204" href="#L1204">1204</a><a id="L1205" href="#L1205">1205</a><a id="L1206" href="#L1206">1206</a><a id="L1207" href="#L1207">1207</a><a id="L1208" href="#L1208">1208</a><a id="L1209" href="#L1209">1209</a><a id="L1210" href="#L1210">1210</a><a id="L1211" href="#L1211">1211</a><a id="L1212" href="#L1212">1212</a><a id="L1213" href="#L1213">1213</a><a id="L1214" href="#L1214">1214</a><a id="L1215" href="#L1215">1215</a><a id="L1216" href="#L1216">1216</a><a id="L1217" href="#L1217">1217</a><a id="L1218" href="#L1218">1218</a><a id="L1219" href="#L1219">1219</a><a id="L1220" href="#L1220">1220</a><a id="L1221" href="#L1221">1221</a><a id="L1222" href="#L1222">1222</a><a id="L1223" href="#L1223">1223</a><a id="L1224" href="#L1224">1224</a><a id="L1225" href="#L1225">1225</a><a id="L1226" href="#L1226">1226</a><a id="L1227" href="#L1227">1227</a><a id="L1228" href="#L1228">1228</a><a id="L1229" href="#L1229">1229</a><a id="L1230" href="#L1230">1230</a><a id="L1231" href="#L1231">1231</a><a id="L1232" href="#L1232">1232</a><a id="L1233" href="#L1233">1233</a><a id="L1234" href="#L1234">1234</a><a id="L1235" href="#L1235">1235</a><a id="L1236" href="#L1236">1236</a><a id="L1237" href="#L1237">1237</a><a id="L1238" href="#L1238">1238</a><a id="L1239" href="#L1239">1239</a><a id="L1240" href="#L1240">1240</a><a id="L1241" href="#L1241">1241</a><a id="L1242" href="#L1242">1242</a><a id="L1243" href="#L1243">1243</a><a id="L1244" href="#L1244">1244</a><a id="L1245" href="#L1245">1245</a><a id="L1246" href="#L1246">1246</a><a id="L1247" href="#L1247">1247</a><a id="L1248" href="#L1248">1248</a><a id="L1249" href="#L1249">1249</a><a id="L1250" href="#L1250">1250</a><a id="L1251" href="#L1251">1251</a><a id="L1252" href="#L1252">1252</a><a id="L1253" href="#L1253">1253</a><a id="L1254" href="#L1254">1254</a><a id="L1255" href="#L1255">1255</a><a id="L1256" href="#L1256">1256</a><a id="L1257" href="#L1257">1257</a><a id="L1258" href="#L1258">1258</a><a id="L1259" href="#L1259">1259</a><a id="L1260" href="#L1260">1260</a><a id="L1261" href="#L1261">1261</a><a id="L1262" href="#L1262">1262</a><a id="L1263" href="#L1263">1263</a><a id="L1264" href="#L1264">1264</a><a id="L1265" href="#L1265">1265</a><a id="L1266" href="#L1266">1266</a><a id="L1267" href="#L1267">1267</a><a id="L1268" href="#L1268">1268</a><a id="L1269" href="#L1269">1269</a><a id="L1270" href="#L1270">1270</a><a id="L1271" href="#L1271">1271</a><a id="L1272" href="#L1272">1272</a><a id="L1273" href="#L1273">1273</a><a id="L1274" href="#L1274">1274</a><a id="L1275" href="#L1275">1275</a><a id="L1276" href="#L1276">1276</a><a id="L1277" href="#L1277">1277</a><a id="L1278" href="#L1278">1278</a><a id="L1279" href="#L1279">1279</a><a id="L1280" href="#L1280">1280</a><a id="L1281" href="#L1281">1281</a><a id="L1282" href="#L1282">1282</a><a id="L1283" href="#L1283">1283</a><a id="L1284" href="#L1284">1284</a><a id="L1285" href="#L1285">1285</a><a id="L1286" href="#L1286">1286</a><a id="L1287" href="#L1287">1287</a><a id="L1288" href="#L1288">1288</a><a id="L1289" href="#L1289">1289</a><a id="L1290" href="#L1290">1290</a><a id="L1291" href="#L1291">1291</a><a id="L1292" href="#L1292">1292</a><a id="L1293" href="#L1293">1293</a><a id="L1294" href="#L1294">1294</a><a id="L1295" href="#L1295">1295</a><a id="L1296" href="#L1296">1296</a><a id="L1297" href="#L1297">1297</a><a id="L1298" href="#L1298">1298</a><a id="L1299" href="#L1299">1299</a><a id="L1300" href="#L1300">1300</a><a id="L1301" href="#L1301">1301</a><a id="L1302" href="#L1302">1302</a><a id="L1303" href="#L1303">1303</a><a id="L1304" href="#L1304">1304</a><a id="L1305" href="#L1305">1305</a><a id="L1306" href="#L1306">1306</a><a id="L1307" href="#L1307">1307</a><a id="L1308" href="#L1308">1308</a><a id="L1309" href="#L1309">1309</a><a id="L1310" href="#L1310">1310</a><a id="L1311" href="#L1311">1311</a><a id="L1312" href="#L1312">1312</a><a id="L1313" href="#L1313">1313</a><a id="L1314" href="#L1314">1314</a><a id="L1315" href="#L1315">1315</a><a id="L1316" href="#L1316">1316</a><a id="L1317" href="#L1317">1317</a><a id="L1318" href="#L1318">1318</a><a id="L1319" href="#L1319">1319</a><a id="L1320" href="#L1320">1320</a><a id="L1321" href="#L1321">1321</a><a id="L1322" href="#L1322">1322</a><a id="L1323" href="#L1323">1323</a><a id="L1324" href="#L1324">1324</a><a id="L1325" href="#L1325">1325</a><a id="L1326" href="#L1326">1326</a><a id="L1327" href="#L1327">1327</a><a id="L1328" href="#L1328">1328</a><a id="L1329" href="#L1329">1329</a><a id="L1330" href="#L1330">1330</a><a id="L1331" href="#L1331">1331</a><a id="L1332" href="#L1332">1332</a><a id="L1333" href="#L1333">1333</a><a id="L1334" href="#L1334">1334</a><a id="L1335" href="#L1335">1335</a><a id="L1336" href="#L1336">1336</a><a id="L1337" href="#L1337">1337</a><a id="L1338" href="#L1338">1338</a><a id="L1339" href="#L1339">1339</a><a id="L1340" href="#L1340">1340</a><a id="L1341" href="#L1341">1341</a><a id="L1342" href="#L1342">1342</a><a id="L1343" href="#L1343">1343</a><a id="L1344" href="#L1344">1344</a><a id="L1345" href="#L1345">1345</a><a id="L1346" href="#L1346">1346</a><a id="L1347" href="#L1347">1347</a><a id="L1348" href="#L1348">1348</a><a id="L1349" href="#L1349">1349</a><a id="L1350" href="#L1350">1350</a><a id="L1351" href="#L1351">1351</a><a id="L1352" href="#L1352">1352</a><a id="L1353" href="#L1353">1353</a><a id="L1354" href="#L1354">1354</a><a id="L1355" href="#L1355">1355</a><a id="L1356" href="#L1356">1356</a><a id="L1357" href="#L1357">1357</a><a id="L1358" href="#L1358">1358</a><a id="L1359" href="#L1359">1359</a><a id="L1360" href="#L1360">1360</a><a id="L1361" href="#L1361">1361</a><a id="L1362" href="#L1362">1362</a><a id="L1363" href="#L1363">1363</a><a id="L1364" href="#L1364">1364</a><a id="L1365" href="#L1365">1365</a><a id="L1366" href="#L1366">1366</a><a id="L1367" href="#L1367">1367</a><a id="L1368" href="#L1368">1368</a><a id="L1369" href="#L1369">1369</a><a id="L1370" href="#L1370">1370</a><a id="L1371" href="#L1371">1371</a><a id="L1372" href="#L1372">1372</a><a id="L1373" href="#L1373">1373</a><a id="L1374" href="#L1374">1374</a><a id="L1375" href="#L1375">1375</a><a id="L1376" href="#L1376">1376</a><a id="L1377" href="#L1377">1377</a><a id="L1378" href="#L1378">1378</a><a id="L1379" href="#L1379">1379</a><a id="L1380" href="#L1380">1380</a><a id="L1381" href="#L1381">1381</a><a id="L1382" href="#L1382">1382</a><a id="L1383" href="#L1383">1383</a><a id="L1384" href="#L1384">1384</a><a id="L1385" href="#L1385">1385</a><a id="L1386" href="#L1386">1386</a><a id="L1387" href="#L1387">1387</a><a id="L1388" href="#L1388">1388</a><a id="L1389" href="#L1389">1389</a><a id="L1390" href="#L1390">1390</a><a id="L1391" href="#L1391">1391</a><a id="L1392" href="#L1392">1392</a><a id="L1393" href="#L1393">1393</a><a id="L1394" href="#L1394">1394</a><a id="L1395" href="#L1395">1395</a><a id="L1396" href="#L1396">1396</a><a id="L1397" href="#L1397">1397</a><a id="L1398" href="#L1398">1398</a><a id="L1399" href="#L1399">1399</a><a id="L1400" href="#L1400">1400</a><a id="L1401" href="#L1401">1401</a><a id="L1402" href="#L1402">1402</a><a id="L1403" href="#L1403">1403</a><a id="L1404" href="#L1404">1404</a><a id="L1405" href="#L1405">1405</a><a id="L1406" href="#L1406">1406</a><a id="L1407" href="#L1407">1407</a><a id="L1408" href="#L1408">1408</a><a id="L1409" href="#L1409">1409</a><a id="L1410" href="#L1410">1410</a><a id="L1411" href="#L1411">1411</a><a id="L1412" href="#L1412">1412</a><a id="L1413" href="#L1413">1413</a><a id="L1414" href="#L1414">1414</a><a id="L1415" href="#L1415">1415</a><a id="L1416" href="#L1416">1416</a><a id="L1417" href="#L1417">1417</a><a id="L1418" href="#L1418">1418</a><a id="L1419" href="#L1419">1419</a><a id="L1420" href="#L1420">1420</a><a id="L1421" href="#L1421">1421</a><a id="L1422" href="#L1422">1422</a><a id="L1423" href="#L1423">1423</a><a id="L1424" href="#L1424">1424</a><a id="L1425" href="#L1425">1425</a><a id="L1426" href="#L1426">1426</a><a id="L1427" href="#L1427">1427</a><a id="L1428" href="#L1428">1428</a><a id="L1429" href="#L1429">1429</a><a id="L1430" href="#L1430">1430</a><a id="L1431" href="#L1431">1431</a><a id="L1432" href="#L1432">1432</a><a id="L1433" href="#L1433">1433</a><a id="L1434" href="#L1434">1434</a><a id="L1435" href="#L1435">1435</a><a id="L1436" href="#L1436">1436</a><a id="L1437" href="#L1437">1437</a><a id="L1438" href="#L1438">1438</a><a id="L1439" href="#L1439">1439</a><a id="L1440" href="#L1440">1440</a><a id="L1441" href="#L1441">1441</a><a id="L1442" href="#L1442">1442</a><a id="L1443" href="#L1443">1443</a><a id="L1444" href="#L1444">1444</a><a id="L1445" href="#L1445">1445</a><a id="L1446" href="#L1446">1446</a><a id="L1447" href="#L1447">1447</a><a id="L1448" href="#L1448">1448</a><a id="L1449" href="#L1449">1449</a><a id="L1450" href="#L1450">1450</a><a id="L1451" href="#L1451">1451</a><a id="L1452" href="#L1452">1452</a><a id="L1453" href="#L1453">1453</a><a id="L1454" href="#L1454">1454</a><a id="L1455" href="#L1455">1455</a><a id="L1456" href="#L1456">1456</a><a id="L1457" href="#L1457">1457</a><a id="L1458" href="#L1458">1458</a><a id="L1459" href="#L1459">1459</a><a id="L1460" href="#L1460">1460</a><a id="L1461" href="#L1461">1461</a><a id="L1462" href="#L1462">1462</a><a id="L1463" href="#L1463">1463</a><a id="L1464" href="#L1464">1464</a><a id="L1465" href="#L1465">1465</a><a id="L1466" href="#L1466">1466</a><a id="L1467" href="#L1467">1467</a><a id="L1468" href="#L1468">1468</a><a id="L1469" href="#L1469">1469</a><a id="L1470" href="#L1470">1470</a><a id="L1471" href="#L1471">1471</a><a id="L1472" href="#L1472">1472</a><a id="L1473" href="#L1473">1473</a><a id="L1474" href="#L1474">1474</a><a id="L1475" href="#L1475">1475</a><a id="L1476" href="#L1476">1476</a><a id="L1477" href="#L1477">1477</a><a id="L1478" href="#L1478">1478</a><a id="L1479" href="#L1479">1479</a><a id="L1480" href="#L1480">1480</a><a id="L1481" href="#L1481">1481</a><a id="L1482" href="#L1482">1482</a><a id="L1483" href="#L1483">1483</a><a id="L1484" href="#L1484">1484</a><a id="L1485" href="#L1485">1485</a><a id="L1486" href="#L1486">1486</a><a id="L1487" href="#L1487">1487</a><a id="L1488" href="#L1488">1488</a><a id="L1489" href="#L1489">1489</a></td>
<td><td><pre class="sourcecode">
<span class="bc">/*******************************************************************************
    Random number generators
    
    This is an attempt at having a good flexible and easy to use random number
    generator.
    ease of use:
    $(UL
      $(LI  shared generator for quick usage available through the "rand" object
            ---
            int i=rand.uniformR(10); // a random number from [0;10)
            ---
      )
      $(LI  simple Random (non threadsafe) and RandomSync (threadsafe) types to 
            create new generators (for heavy use a good idea is one Random object per thread)
      )
      $(LI  several distributions can be requested like this
            ---
            rand.distributionD!(type)(paramForDistribution)
            ---
            the type can often be avoided if the parameters make it clear.
            From it single numbers can be generated with .getRandom(), and variables
            initialized either with call style (var) or with .randomize(var).
            Utility functions to generate numbers directly are also available.
            The choice to put all the distribution in a single object that caches them
            has made (for example) the gamma distribution very easy to implement.
      )
      $(LI  sample usage:
            ---
            auto r=new Random();
            int i; float f; real rv; real[100] ar0; real[] ar=ar0[];
            // initialize with uniform distribution
            i=r.uniform!(int);
            f=r.uniform!(float);
            rv=r.uniform!(real);
            foreach (ref el;ar)
              el=r.uniform!(real);
            // another way to do all the previous in one go:
            r(i)(f)(rv)(ar);
            // unfortunetely one cannot use directly ar0...
            // uniform distribution 0..10
            i=r.uniformR(10);
            f=r.uniformR(10.0f);
            rv=r.uniformR(10.0L);
            foreach (ref el;ar)
              el=r.uniformR(10.0L);
            // another way to do all the previous in one go:
            r.uniformRD(10)(i)(f)(r)(ar);
            // uniform numbers in [5;10)
            i=r.uniformR2(5,10);
            // uniform numbers in (5;10)
            f=r.uniformR2(5.0f,10.0f);
            rv=r.uniformR2(5.0L,10.0L);
            foreach (ref el;ar)
              el=r.uniformR2(5.0L,10.0L);
            // another way to do all the previous in one go:
            r.uniformR2D(5.0L,10.0L)(i)(f)(r)(ar);
            // uniform distribution -10..10
            i=r.uniformRSymm(10);
            // well you get it...
            r.uniformRSymmD(10)(i)(f)(r)(ar);
            // any distribution can be stored
            auto r2=r.uniformRSymmD(10);
            // and used later
            r2(ar);
            // complex distributions (normal,exp,gamma) are produced for the requested type
            r.normalSource!(float)()(f);
            // with sigma=2
            r.normalD(2.0f)(f);
            // and can be used also to initialize other types
            r.normalSource!(float)()(r)(ar);
            r.normalD(2.0f)(r)(ar);
            // but this is different from
            r.normalSource!(real)()(i)(r)(ar);
            r.normalD(2.0L)(i)(r)(ar);
            // as the source generates numbers of its type that then are simply cast to
            // the type needed.
            // Uniform distribution (as its creation for different types has no overhead)
            // is never cast, so that (for example) bounds exclusion for floats is really
            // guaranteed.
            // For the other distribution using a distribution of different type than
            // the variable should be done with care, as underflow/overflow might ensue.
            //
            // Some utility functions are also available
            int i2=r.uniform!(int)();
            int i2=r.randomize(i); // both i and i2 are initialized to the same value
            float f2=r.normalSigma(3.0f);
            ---
      )
    )
    flexibility:
    $(UL
      $(LI  easily swappable basic source
            ---
            // a random generator that uses the system provided random generator:
            auto r=RandomG!(Urandom)();
            ---
            One could also build an engine that can be changed at runtime (that calls
            a delegate for example), but this adds a little overhead, and changing
            engine is not something done often, so this is not part of the library.
      )
      $(LI  ziggurat generator can be easily adapted to any decreasing derivable
            distribution, the hard parametrization (to find xLast) can be done
            automatically
      )
      $(LI  several distributions available "out of the box"
      )
      )
      Quality:
      $(UL
      $(LI  the default Source combines two surces that pass all statistical tests 
            (KISS+CMWC)
            (P. L'Ecuyer and R. Simard, ACM Transactions on Mathematical Software (2007),
            33, 4, Article 22, for KISS, see CMWC engine for the other)
      )
      $(LI  floating point uniform generator always initializes the full mantissa, the
            only flaw is a (*very* small) predilection of 0 as least important bit 
            (IEEE rounds to 0 in case of tie).
            Using a method that initializes the full mantissa was shown to improve the
            quality of subsequntly derived normal distribued numbers
            (Thomas et al. Gaussian random number generators. Acm Comput Surv (2007)
            vol. 39 (4) pp. 11))
      )
      $(LI  Ziggurat method, a very fast and accurate method was used for both Normal and
            exp distributed numbers.
      )
      $(LI  gamma distribued numbers uses a method recently proposed by Marsaglia and
            Tsang. The method is very fast, and should be good.
            My (Fawzi's) feeling is that the transformation h(x)=(1+d*x)^3 might lose
            a couple of bits of precision in some cases, but it is unclear if this
            might become visible in (*very* extensive) tests or not.
      )
       the basic source can be easily be changed with something else
      Efficiency:
      $(LI  very fast methods have been used, and some effort has been put into
            optimizing some of them, but not all, but the interface has been choosen
            so that close to optimal implementation can be provided through the same
            interface.
      )
      $(LI  Normal and Exp sources allocated only upon request: no memory waste, but
            a (*very* small) speed hit, that can be avoided by storing the source in
            a variable and using it (not going through the RandomG)
      )
    )
    Annoyances:
    $(UL
      $(LI  I have added two "next" methods to RandomG for backward compatibility
            reasons, and the .instance from Random has been
            replaced by the "rand" object. The idea behind this is that RandomG is
            a template and rand it should be shared across all templates.
            If the name rand is considered bad one could change it. 
            I kept .instance static method that returns rand, so this remain a dropin
            replacement of the old random.
      )
      $(LI You cannot initialize a static array directly, this because randomize is
          declared like this:
            ---
            U randomize(U)(ref U a) { }
            ---
            and a static array cannot be passed by reference. Removing the ref would
            make arrays initialized, and scalar not, which is much worse.
      )
    )

        copyright:      Copyright (c) 2008. Fawzi Mohamed
        license:        BSD style: $(LICENSE)
        version:        Initial release: July 2008
        author:         Fawzi Mohamed

*******************************************************************************/</span>
<span class="d Compound"><span class="d Module"><span class="k">module</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">Random</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">engines</span>.<span class="i">URandom</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">engines</span>.<span class="i">KissCmwc</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">engines</span>.<span class="i">ArraySource</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">engines</span>.<span class="i">Sync</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">engines</span>.<span class="i">Twister</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">NormalSource</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">ExpSource</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">Math</span>;</span>
<span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">core</span>.<span class="i">Traits</span>;</span>

<span class="lc">// ----- templateFu begin --------</span>
<span class="lc">/// compile time integer power</span>
<span class="d Protection"><span class="k">private</span></span> <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">ctfe_powI</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">x</span></span>,<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">p</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">xx</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>;</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">p</span></span>&lt;<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span>=<span class="e Sign">-<span class="e Identifier"><span class="i">p</span></span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span>=<span class="e Div"><span class="e Int"><span class="n">1</span></span>/<span class="e Identifier"><span class="i">x</span></span></span></span>;</span>
    }</span></span></span>
    <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Identifier"><span class="i">p</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>)
        <span class="s Scope"><span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">xx</span></span>*=<span class="e Identifier"><span class="i">x</span></span></span>;</span></span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">xx</span></span>;</span>
}</span></span></span></span></span>
<span class="lc">// ----- templateFu end --------</span>

<span class="d Version"><span class="k">version</span> (<span class="i">Win32</span>) <span class="d Compound">{
         <span class="d Protection"><span class="k">private</span></span> <span class="d Linkage"><span class="k">extern</span>(<span class="i">Windows</span>)</span> <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">QueryPerformanceCounter</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">ulong</span></span> <span class="t Pointer">*</span></span>)</span><span class="s FuncBody">;</span></span>
}</span></span>
<span class="d Version"><span class="k">version</span> (<span class="i">Posix</span>) <span class="d Compound">{
    <span class="d Protection"><span class="k">private</span></span> <span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">stdc</span>.<span class="i">posix</span>.<span class="i">sys</span>.<span class="i">time</span>;</span>
}</span></span>

<span class="d Version"><span class="k">version</span>(<span class="i">darwin</span>) <span class="d Compound">{ <span class="d Version"><span class="k">version</span>=<span class="i">has_urandom</span>;</span> }</span></span>
<span class="d Version"><span class="k">version</span>(<span class="i">linux</span>)  <span class="d Compound">{ <span class="d Version"><span class="k">version</span>=<span class="i">has_urandom</span>;</span> }</span></span>
<span class="d Version"><span class="k">version</span>(<span class="i">solaris</span>)<span class="d Compound">{ <span class="d Version"><span class="k">version</span>=<span class="i">has_urandom</span>;</span> }</span></span>

<span class="lc">/// if T is a float</span>
<span class="d Template"><span class="k">template</span> <span class="i">isFloat</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="d Compound">{
    <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span>(<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>)<span class="d Compound">{
        <span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">isFloat</span>=<span class="e Bool"><span class="k">true</span></span>;</span>
    }</span> <span class="k">else</span> <span class="d Compound">{
        <span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">isFloat</span>=<span class="e Bool"><span class="k">false</span></span>;</span>
    }</span></span>
}</span></span>

<span class="lc">/// The default engine, a reasonably collision free, with good statistical properties</span>
<span class="lc">/// not easy to invert, and with a relatively small key (but not too small)</span>
<span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">KissCmwc_32_1</span></span> <span class="i">DefaultEngine</span>;</span></span>

<span class="lc">/// Class that represents a random number generator.</span>
<span class="lc">/// Normally you should get random numbers either with call-like interface:</span>
<span class="lc">///   auto r=new Random(); r(i)(j)(k);</span>
<span class="lc">/// or with randomize</span>
<span class="lc">///   r.randomize(i); r.randomize(j); r.randomize(k);</span>
<span class="lc">/// if you use this you should be able to easily switch distribution later,</span>
<span class="lc">/// as all distributions support this interface, and can be built on the top of RandomG</span>
<span class="lc">///   auto r2=r.NormalSource!(float)(); r2(i)(j)(k);</span>
<span class="lc">/// there are utility methods within random for the cases in which you do not</span>
<span class="lc">/// want to build a special distribution for just a few numbers</span>
<span class="d StorageClass"><span class="k">final</span></span> <span class="d Template"><span class="d Compound"><span class="d Class"><span class="k">class</span> <span class="i">RandomG</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">SourceT</span>=<span class="t Identifier"><span class="i">DefaultEngine</span></span></span>)</span>
<span class="d Compound">{
    <span class="lc">// uniform random source</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">SourceT</span></span> <span class="i">source</span>;</span>
    <span class="lc">// normal distributed sources</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">NormalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Integral"><span class="k">float</span></span>)</span></span>  <span class="i">normalFloat</span>;</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">NormalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Integral"><span class="k">double</span></span>)</span></span> <span class="i">normalDouble</span>;</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">NormalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Integral"><span class="k">real</span></span>)</span></span>   <span class="i">normalReal</span>;</span>
    <span class="lc">// exp distributed sources</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">ExpSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Integral"><span class="k">float</span></span>)</span></span>  <span class="i">expFloat</span>;</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">ExpSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Integral"><span class="k">double</span></span>)</span></span> <span class="i">expDouble</span>;</span>
    <span class="d Variables"><span class="t TemplateInstance"><span class="i">ExpSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Integral"><span class="k">real</span></span>)</span></span>   <span class="i">expReal</span>;</span>

    <span class="lc">/// Creates and seeds a new generator</span>
    <span class="d Constructor"><span class="k">this</span> <span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">bool</span></span> <span class="i">randomInit</span>=<span class="e Bool"><span class="k">true</span></span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">randomInit</span></span>)
            <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e This"><span class="k">this</span></span>.<span class="e Identifier"><span class="i">seed</span></span>()</span>;</span></span></span>
    }</span></span></span>
    
    <span class="lc">/// if source.canSeed seeds the generator using the shared rand generator</span>
    <span class="lc">/// (use urandom directly if available?)</span>
    <span class="d Function"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">seed</span> <span class="o Parameters">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span>(<span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">canSeed</span></span>)<span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">seed</span></span>(&amp;<span class="i">rand</span>.<span class="i">uniform</span>!(<span class="k">uint</span>))</span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>
    <span class="lc">/// if source.canSeed seeds the generator using the given source of uints</span>
    <span class="d Function"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">seed</span> <span class="o Parameters">(<span class="o Parameter"><span class="k">scope</span> <span class="t Integral"><span class="k">uint</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o Parameters">()</span></span> <span class="i">seedSource</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span>(<span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">canSeed</span></span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">source</span></span>.<span class="t Identifier"><span class="i">seed</span></span>(<span class="i">seedSource</span>);</span></span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span>
    
    <span class="lc">/// compatibility with old Random, deprecate??</span>
    <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">next</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">uint</span></span>)</span></span>()</span>;</span>
    }</span></span></span>
    <span class="lc">/// ditto</span>
    <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">next</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">uint</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniformR</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">uint</span></span>)</span></span>(<span class="i">to</span>)</span>;</span>
    }</span></span></span>
    <span class="lc">/// ditto</span>
    <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">next</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">uint</span></span> <span class="i">from</span></span>,<span class="o Parameter"><span class="t Integral"><span class="k">uint</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniformR2</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">uint</span></span>)</span></span>(<span class="i">from</span>,<span class="i">to</span>)</span>;</span>
    }</span></span></span>
    <span class="lc">/// ditto</span>
    <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t TemplateInstance"><span class="i">RandomG</span>!<span class="o TemplateArguments">(<span class="t TemplateInstance"><span class="i">Sync</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">DefaultEngine</span></span>)</span></span>)</span></span> <span class="i">instance</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">rand</span></span>;</span>
    }</span></span></span>
    <span class="lc">//-------- Utility functions to quickly get a uniformly distributed random number -----------</span>

    <span class="lc">/// uniform distribution on the whole range of integer types, and on</span>
    <span class="lc">/// the (0;1) range for floating point types. Floating point guarantees the initialization</span>
    <span class="lc">/// of the full mantissa, but due to rounding effects it might have *very* small</span>
    <span class="lc">/// dependence due to rounding effects on the least significant bit (in case of tie 0 is favored).</span>
    <span class="lc">/// if boundCheck is false in the floating point case bounds might be included (but with a</span>
    <span class="lc">/// lower propability than other numbers)</span>
    <span class="d StorageClass">@<span class="i">property</span></span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">uniform</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span>=<span class="e Bool"><span class="k">true</span></span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span>(<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">uint</span></span>)</span>) <span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">short</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ushort</span></span>)</span></span>|| <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">char</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">byte</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Union"><span class="k">union</span> <span class="i">Uint2A</span><span class="d Compound">{
                <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">t</span>;</span>
                <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">u</span>;</span>
            }</span></span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Uint2A</span></span> <span class="i">a</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">u</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">t</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span> || <span class="e Is"><span class="k">is</span> (<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ulong</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">bool</span></span>)</span>)<span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">bool</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span> &amp; <span class="e Int"><span class="n">1u</span></span></span>)</span></span>;</span> <span class="lc">// check lowest bit</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>)<span class="s Compound">{
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>&lt;<span class="e Int"><span class="n">30</span></span></span>) <span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">halfT</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">2</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact32</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">32</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">minV</span>=<span class="e LShift"><span class="e Int"><span class="n">1u</span></span>&lt;&lt;<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>-<span class="e Int"><span class="n">1</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;=<span class="e Identifier"><span class="i">minV</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Identifier"><span class="i">nV</span></span>*<span class="e Identifier"><span class="i">fact32</span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                        <span class="lc">// 1 due to rounding (&lt;3.e-8), 0 impossible</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span>;</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
                    }</span></span>
                }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 0.00390625 for 24 bit mantissa</span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">scale</span>=<span class="e Identifier"><span class="i">fact32</span></span>;</span></span>
                    <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nV</span></span>==<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 2.3283064365386963e-10</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                        <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">scale</span></span>*=<span class="e Identifier"><span class="i">fact32</span></span></span>;</span>
                    }</span></span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">nV</span></span>*<span class="e Identifier"><span class="i">scale</span></span></span>+<span class="e Mul"><span class="e Mul"><span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>*<span class="e Identifier"><span class="i">scale</span></span></span>*<span class="e Identifier"><span class="i">fact32</span></span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span>;</span> <span class="lc">// 0 due to underflow (&lt;1.e-38), 1 impossible</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
                    }</span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>&lt;<span class="e Int"><span class="n">62</span></span></span>) <span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">halfT</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">2</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact64</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">64</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">minV</span>=<span class="e LShift"><span class="e Int"><span class="n">1UL</span></span>&lt;&lt;<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>-<span class="e Int"><span class="n">1</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;=<span class="e Identifier"><span class="i">minV</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Identifier"><span class="i">nV</span></span>*<span class="e Identifier"><span class="i">fact64</span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                        <span class="lc">// 1 due to rounding (&lt;1.e-16), 0 impossible</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span>;</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
                    }</span></span>
                }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 0.00048828125 for 53 bit mantissa</span>
                    <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact32</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">32</span>)</span>;</span></span>
                    <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">minV2</span>=<span class="e LShift"><span class="e Int"><span class="n">1UL</span></span>&lt;&lt;<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>-<span class="e Int"><span class="n">33</span></span></span>)</span></span>;</span></span>
                    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;=<span class="e Identifier"><span class="i">minV2</span></span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nV</span></span></span>)</span>+<span class="e Mul"><span class="e Paren">(<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>)</span>*<span class="e Identifier"><span class="i">fact32</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">fact64</span></span></span>;</span>
                    }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 1.1368683772161603e-13 for 53 bit mantissa</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">scale</span>=<span class="e Identifier"><span class="i">fact64</span></span>;</span></span>
                        <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nV</span></span>==<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span></span>;</span>
                            <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">scale</span></span>*=<span class="e Identifier"><span class="i">fact64</span></span></span>;</span>
                        }</span></span></span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Identifier"><span class="i">scale</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nV</span></span></span>)</span>+<span class="e Mul"><span class="e Paren">(<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>)</span>*<span class="e Identifier"><span class="i">fact64</span></span></span></span>)</span></span>;</span></span>
                        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                            <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                            <span class="lc">// 0 due to underflow (&lt;1.e-307)</span>
                            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span>;</span>
                        }</span> <span class="k">else</span> <span class="s Compound">{
                            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
                        }</span></span>
                    }</span></span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>&lt;=<span class="e Int"><span class="n">64</span></span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">halfT</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">2</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact8</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">8</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact72</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">72</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span> <span class="i">nB</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextB</span></span>()</span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nB</span></span>!=<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">nB</span></span>*<span class="e Identifier"><span class="i">fact8</span></span></span>+<span class="e Mul"><span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>*<span class="e Identifier"><span class="i">fact72</span></span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                        <span class="lc">// 1 due to rounding (&lt;1.e-16), 0 impossible</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span>;</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
                    }</span></span>
                }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 0.00390625</span>
                    <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact64</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">64</span>)</span>;</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">scale</span>=<span class="e Identifier"><span class="i">fact8</span></span>;</span></span>
                    <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nB</span></span>==<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nB</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextB</span></span>()</span></span>;</span>
                        <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">scale</span></span>*=<span class="e Identifier"><span class="i">fact8</span></span></span>;</span>
                    }</span></span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nB</span></span></span>)</span>+<span class="e Mul"><span class="e Paren">(<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>)</span>*<span class="e Identifier"><span class="i">fact64</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">scale</span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                        <span class="lc">// 0 due to underflow (&lt;1.e-4932), 1 impossible</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span>;</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
                    }</span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s Compound">{
                <span class="lc">// (T.mant_dig &gt; 64 bits), not so optimized, but works for any size</span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">halfT</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">2</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact32</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">32</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nL</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact</span>=<span class="e Identifier"><span class="i">fact32</span></span>;</span></span>
                <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nL</span></span>==<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">fact</span></span>*=<span class="e Identifier"><span class="i">fact32</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nL</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                }</span></span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Identifier"><span class="i">nL</span></span>*<span class="e Identifier"><span class="i">fact</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">rBits</span>=<span class="e Minus"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>-<span class="e Int"><span class="n">1</span></span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">rBits</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>;<span class="e MinusAssign"><span class="e Identifier"><span class="i">rBits</span></span>-=<span class="e Int"><span class="n">32</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">fact</span></span>*=<span class="e Identifier"><span class="i">fact32</span></span></span>;</span>
                    <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">res</span></span>+=<span class="e Mul"><span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>*<span class="e Identifier"><span class="i">fact</span></span></span></span>;</span>
                }</span></span></span>
                <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                    <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">res</span></span> !=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span>;</span> <span class="lc">// really unlikely...</span>
                }</span> <span class="k">else</span> <span class="s Compound">{
                    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
                }</span></span>
            }</span></span></span></span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">cfloat</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">cdouble</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">creal</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t TemplateInstance"><span class="i">realType</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>)</span></span>()</span>+<span class="e Mul"><span class="e Float"><span class="n">1i</span></span>*<span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t TemplateInstance"><span class="i">realType</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>)</span></span>()</span></span></span>)</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ifloat</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">idouble</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ireal</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mul"><span class="e Float"><span class="n">1i</span></span>*<span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t TemplateInstance"><span class="i">realType</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>)</span></span>()</span></span>)</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" unsupported type for uniform distribution"</span></span></span>);</span></span></span></span></span></span></span></span>
    }</span></span></span></span></span>
    
    <span class="lc">/// uniform distribution on the range [0;to) for integer types, and on</span>
    <span class="lc">/// the (0;to) range for floating point types. Same caveat as uniform(T) apply</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">uniformR</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span>=<span class="e Bool"><span class="k">true</span></span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span> <span class="s Compound">{ <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">to</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"empty range"</span></span>)</span>;</span>}</span>
    <span class="k">body</span> <span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">uint</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">short</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ushort</span></span>)</span></span> 
            || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">char</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">byte</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>)
        <span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">d</span>=<span class="e Div"><span class="e TypeDotId"><span class="t Integral"><span class="k">uint</span></span>.<span class="i">max</span></span>/<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>,<span class="i">dTo</span>=<span class="e Mul"><span class="e Identifier"><span class="i">to</span></span>*<span class="e Identifier"><span class="i">d</span></span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;=<span class="e Identifier"><span class="i">dTo</span></span></span>)<span class="s Scope"><span class="s Compound">{
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Int"><span class="n">1000</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>) <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                }</span></span></span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>,<span class="e String"><span class="sl">"this is less probable than 1.e-301, something is wrong with the random number generator"</span></span>)</span>;</span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>%<span class="e Identifier"><span class="i">to</span></span></span>)</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ulong</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">d</span>=<span class="e Div"><span class="e TypeDotId"><span class="t Integral"><span class="k">ulong</span></span>.<span class="i">max</span></span>/<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ulong</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>,<span class="i">dTo</span>=<span class="e Mul"><span class="e Identifier"><span class="i">to</span></span>*<span class="e Identifier"><span class="i">d</span></span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;=<span class="e Identifier"><span class="i">dTo</span></span></span>)<span class="s Scope"><span class="s Compound">{
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Int"><span class="n">1000</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span></span>;</span>
                    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>) <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                }</span></span></span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>,<span class="e String"><span class="sl">"this is less probable than 1.e-301, something is wrong with the random number generator"</span></span>)</span>;</span>
            }</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>%<span class="e Identifier"><span class="i">to</span></span></span>)</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span>|| <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span>()</span>*<span class="e Identifier"><span class="i">to</span></span></span>;</span></span>
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Identifier"><span class="i">to</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformR</span></span>(<span class="i">to</span>)</span>;</span>
            }</span> <span class="k">else</span> <span class="s Compound">{
                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
            }</span></span>
        }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" unsupported type for uniformR distribution"</span></span></span>);</span></span></span></span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution on the range (-to;to) for integer types, and on</span>
    <span class="lc">/// the (-to;0)(0;to) range for floating point types if boundCheck is true.</span>
    <span class="lc">/// If boundCheck=false the range changes to [-to;0)u(0;to] with a slightly</span>
    <span class="lc">/// lower propability at the bounds for floating point numbers.</span>
    <span class="lc">/// excludeZero controls if 0 is excluded or not (by default float exclude it,</span>
    <span class="lc">/// ints no). Please note that the probability of 0 in floats is very small due</span>
    <span class="lc">//  to the high density of floats close to 0.</span>
    <span class="lc">/// Cannot be used on unsigned types.</span>
    <span class="lc">///</span>
    <span class="lc">/// In here there is probably one of the few cases where c handling of modulo of negative</span>
    <span class="lc">/// numbers is handy</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">uniformRSymm</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span>=<span class="e Bool"><span class="k">true</span></span></span>, <span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">excludeZero</span>=<span class="e TmplInstance"><span class="i">isFloat</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>,<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">iter</span>=<span class="e Int"><span class="n">2000</span></span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span> <span class="s Compound">{ <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">to</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"empty range"</span></span>)</span>;</span>}</span>
    <span class="k">body</span> <span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span>|| <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">short</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">byte</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">d</span>=<span class="e Div"><span class="e TypeDotId"><span class="t Integral"><span class="k">int</span></span>.<span class="i">max</span></span>/<span class="e Identifier"><span class="i">to</span></span></span>,<span class="i">dTo</span>=<span class="e Mul"><span class="e Identifier"><span class="i">to</span></span>*<span class="e Identifier"><span class="i">d</span></span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">excludeZero</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">isIn</span>=<span class="e AndAnd"><span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>&amp;&amp;<span class="e Equal"><span class="e Identifier"><span class="i">nV</span></span>!=<span class="e Int"><span class="n">0</span></span></span></span>;</span></span>
            }</span> <span class="k">else</span> <span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">isIn</span>=<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>;</span></span>
            }</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">isIn</span></span>)<span class="s Scope"><span class="s Compound">{
                <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>%<span class="e Identifier"><span class="i">to</span></span></span>)</span></span>;</span>
            }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Int"><span class="n">1000</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                    <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>) <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                }</span></span></span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>,<span class="e String"><span class="sl">"this is less probable than 1.e-301, something is wrong with the random number generator"</span></span>)</span>;</span>
                <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>%<span class="e Identifier"><span class="i">to</span></span></span>)</span></span>;</span>
            }</span></span></span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">long</span></span> <span class="i">d</span>=<span class="e Div"><span class="e TypeDotId"><span class="t Integral"><span class="k">long</span></span>.<span class="i">max</span></span>/<span class="e Identifier"><span class="i">to</span></span></span>,<span class="i">dTo</span>=<span class="e Mul"><span class="e Identifier"><span class="i">to</span></span>*<span class="e Identifier"><span class="i">d</span></span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">long</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">long</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">excludeZero</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">isIn</span>=<span class="e AndAnd"><span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>&amp;&amp;<span class="e Equal"><span class="e Identifier"><span class="i">nV</span></span>!=<span class="e Int"><span class="n">0</span></span></span></span>;</span></span>
            }</span> <span class="k">else</span> <span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">isIn</span>=<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>;</span></span>
            }</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">isIn</span></span>)<span class="s Scope"><span class="s Compound">{
                <span class="s Return"><span class="k">return</span> <span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>%<span class="e Identifier"><span class="i">to</span></span></span>;</span>
            }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Int"><span class="n">1000</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span></span>;</span>
                    <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>) <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                }</span></span></span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>,<span class="e String"><span class="sl">"this is less probable than 1.e-301, something is wrong with the random number generator"</span></span>)</span>;</span>
                <span class="s Return"><span class="k">return</span> <span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>%<span class="e Identifier"><span class="i">to</span></span></span>;</span>
            }</span></span></span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>)<span class="s Compound">{
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>&lt;<span class="e Int"><span class="n">30</span></span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">halfT</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">2</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact32</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">32</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">minV</span>=<span class="e LShift"><span class="e Int"><span class="n">1u</span></span>&lt;&lt;<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;=<span class="e Identifier"><span class="i">minV</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">nV</span></span>*<span class="e Identifier"><span class="i">fact32</span></span></span>*<span class="e Identifier"><span class="i">to</span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Identifier"><span class="i">to</span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV</span></span>&amp;<span class="e Int"><span class="n">1u</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span></span></span>
                        <span class="lc">// to due to rounding (~3.e-8), 0 impossible with normal to values</span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">iter</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"error with the generator, probability &lt; 10^(-8*2000)"</span></span>)</span>;</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformRSymm</span></span>(<span class="i">to</span>,<span class="i">iter</span>-<span class="n">1</span>)</span>;</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV</span></span>&amp;<span class="e Int"><span class="n">1u</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span>
                    }</span></span>
                }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 0.008 for 24 bit mantissa</span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">scale</span>=<span class="e Identifier"><span class="i">fact32</span></span>;</span></span>
                    <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nV</span></span>==<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 2.3283064365386963e-10</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                        <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">scale</span></span>*=<span class="e Identifier"><span class="i">fact32</span></span></span>;</span>
                    }</span></span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nV2</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Mul"><span class="e Paren">(<span class="e Plus"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nV</span></span></span>+<span class="e Mul"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nV2</span></span></span>*<span class="e Identifier"><span class="i">fact32</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">scale</span></span></span>*<span class="e Identifier"><span class="i">to</span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">excludeZero</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV</span></span>&amp;<span class="e Int"><span class="n">1u</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span></span></span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">iter</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"error with the generator, probability &lt; 10^(-8*2000)"</span></span>)</span>;</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformRSymm</span></span>(<span class="i">to</span>,<span class="i">iter</span>-<span class="n">1</span>)</span>;</span> <span class="lc">// 0 due to underflow (&lt;1.e-38), 1 impossible</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV</span></span>&amp;<span class="e Int"><span class="n">1u</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span>
                    }</span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>&lt;<span class="e Int"><span class="n">62</span></span></span>) <span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">halfT</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">2</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact64</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">64</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">minV</span>=<span class="e LShift"><span class="e Int"><span class="n">1UL</span></span>&lt;&lt;<span class="e Paren">(<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;=<span class="e Identifier"><span class="i">minV</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">nV</span></span>*<span class="e Identifier"><span class="i">fact64</span></span></span>*<span class="e Identifier"><span class="i">to</span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Identifier"><span class="i">to</span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span></span></span>
                        <span class="lc">// to due to rounding (&lt;1.e-16), 0 impossible with normal to values</span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">iter</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"error with the generator, probability &lt; 10^(-16*2000)"</span></span>)</span>;</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformRSymm</span></span>(<span class="i">to</span>,<span class="i">iter</span>-<span class="n">1</span>)</span>;</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span>
                    }</span></span>
                }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 0.00048828125 for 53 bit mantissa</span>
                    <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact32</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">32</span>)</span>;</span></span>
                    <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">minV2</span>=<span class="e LShift"><span class="e Int"><span class="n">1UL</span></span>&lt;&lt;<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>-<span class="e Int"><span class="n">32</span></span></span>)</span></span>;</span></span>
                    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;=<span class="e Identifier"><span class="i">minV2</span></span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nV2</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Mul"><span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nV</span></span></span>)</span>+<span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nV2</span></span></span>)</span>*<span class="e Identifier"><span class="i">fact32</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">fact64</span></span></span>*<span class="e Identifier"><span class="i">to</span></span></span>;</span></span>
                        <span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV2</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span> <span class="lc">// cannot be 0 or to with normal to values</span>
                    }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 1.1368683772161603e-13 for 53 bit mantissa</span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">scale</span>=<span class="e Identifier"><span class="i">fact64</span></span>;</span></span>
                        <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nV</span></span>==<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span></span>;</span>
                            <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">scale</span></span>*=<span class="e Identifier"><span class="i">fact64</span></span></span>;</span>
                        }</span></span></span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">nV2</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
                        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">to</span></span>*<span class="e Identifier"><span class="i">scale</span></span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nV</span></span></span>)</span>+<span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nV2</span></span></span>)</span>*<span class="e Identifier"><span class="i">fact64</span></span></span></span>)</span></span>;</span></span>
                        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">excludeZero</span></span>)<span class="s Compound">{
                            <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV2</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span></span></span>
                            <span class="lc">// 0 due to underflow (&lt;1.e-307)</span>
                            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">iter</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"error with the generator, probability &lt; 10^(-16*2000)"</span></span>)</span>;</span>
                            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformRSymm</span></span>(<span class="i">to</span>,<span class="i">iter</span>-<span class="n">1</span>)</span>;</span>
                        }</span> <span class="k">else</span> <span class="s Compound">{
                            <span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nV2</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span>
                        }</span></span>
                    }</span></span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>&lt;=<span class="e Int"><span class="n">64</span></span></span>) <span class="s Compound">{
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">halfT</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">2</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact8</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">8</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact72</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">72</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span> <span class="i">nB</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextB</span></span>()</span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nB</span></span>!=<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">nL</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Identifier"><span class="i">to</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">nB</span></span>*<span class="e Identifier"><span class="i">fact8</span></span></span>+<span class="e Mul"><span class="e Identifier"><span class="i">nL</span></span>*<span class="e Identifier"><span class="i">fact72</span></span></span></span>)</span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Identifier"><span class="i">to</span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nL</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span></span></span>
                        <span class="lc">// 1 due to rounding (&lt;1.e-16), 0 impossible with normal to values</span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">iter</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"error with the generator, probability &lt; 10^(-16*2000)"</span></span>)</span>;</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformRSymm</span></span>(<span class="i">to</span>,<span class="i">iter</span>-<span class="n">1</span>)</span>;</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Int"><span class="n">2</span></span>*<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nL</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">res</span></span></span>;</span>
                    }</span></span>
                }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{ <span class="lc">// probability 0.00390625</span>
                    <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact64</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">64</span>)</span>;</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">scale</span>=<span class="e Identifier"><span class="i">fact8</span></span>;</span></span>
                    <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nB</span></span>==<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nB</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextB</span></span>()</span></span>;</span>
                        <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">scale</span></span>*=<span class="e Identifier"><span class="i">fact8</span></span></span>;</span>
                    }</span></span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">nL</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Mul"><span class="e Paren">(<span class="e Plus"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nB</span></span></span>)</span>+<span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">nL</span></span></span>)</span>*<span class="e Identifier"><span class="i">fact64</span></span></span></span>)</span>*<span class="e Identifier"><span class="i">scale</span></span></span>*<span class="e Identifier"><span class="i">to</span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">excludeZero</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Paren">(<span class="e Cond"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nL</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span>?<span class="e Identifier"><span class="i">res</span></span>:<span class="e Sign">-<span class="e Identifier"><span class="i">res</span></span></span></span>)</span>;</span></span></span>
                        <span class="lc">// 0 due to underflow (&lt;1.e-4932), 1 impossible</span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">iter</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"error with the generator, probability &lt; 10^(-16*2000)"</span></span>)</span>;</span>
                        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformRSymm</span></span>(<span class="i">to</span>,<span class="i">iter</span>-<span class="n">1</span>)</span>;</span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Return"><span class="k">return</span> <span class="e Paren">(<span class="e Cond"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nL</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span>?<span class="e Identifier"><span class="i">res</span></span>:<span class="e Sign">-<span class="e Identifier"><span class="i">res</span></span></span></span>)</span>;</span>
                    }</span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s Compound">{
                <span class="lc">// (T.mant_dig &gt; 64 bits), not so optimized, but works for any size</span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">halfT</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">2</span></span></span>)</span></span>;</span></span>
                <span class="s Declaration"><span class="d StorageClass"><span class="k">enum</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact32</span>=<span class="e Call"><span class="e Identifier"><span class="i">ctfe_powI</span></span>(<span class="i">halfT</span>,<span class="n">32</span>)</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nL</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">fact</span>=<span class="e Identifier"><span class="i">fact32</span></span>;</span></span>
                <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">nL</span></span>==<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">fact</span></span>*=<span class="e Identifier"><span class="i">fact32</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nL</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                }</span></span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Mul"><span class="e Identifier"><span class="i">nL</span></span>*<span class="e Identifier"><span class="i">fact</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">rBits</span>=<span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">mant_dig</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">rBits</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>;<span class="e MinusAssign"><span class="e Identifier"><span class="i">rBits</span></span>-=<span class="e Int"><span class="n">32</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e MulAssign"><span class="e Identifier"><span class="i">fact</span></span>*=<span class="e Identifier"><span class="i">fact32</span></span></span>;</span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nL</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                    <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">res</span></span>+=<span class="e Mul"><span class="e Identifier"><span class="i">nL</span></span>*<span class="e Identifier"><span class="i">fact</span></span></span></span>;</span>
                }</span></span></span>
                <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                    <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Identifier"><span class="i">to</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Paren">(<span class="e Cond"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nL</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span>?<span class="e Identifier"><span class="i">res</span></span>:<span class="e Sign">-<span class="e Identifier"><span class="i">res</span></span></span></span>)</span>;</span></span></span>
                    <span class="lc">// 1 due to rounding (&lt;1.e-16), 0 impossible with normal to values</span>
                    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">iter</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"error with the generator, probability &lt; 10^(-16*2000)"</span></span>)</span>;</span>
                    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformRSymm</span></span>(<span class="i">to</span>,<span class="i">iter</span>-<span class="n">1</span>)</span>;</span>
                }</span> <span class="k">else</span> <span class="s Compound">{
                    <span class="s Return"><span class="k">return</span> <span class="e Paren">(<span class="e Cond"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">nL</span></span>&amp;<span class="e Int"><span class="n">1UL</span></span></span>)</span>?<span class="e Identifier"><span class="i">res</span></span>:<span class="e Sign">-<span class="e Identifier"><span class="i">res</span></span></span></span>)</span>;</span>
                }</span></span>
            }</span></span></span></span>
        }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" unsupported type for uniformRSymm distribution"</span></span></span>);</span></span></span></span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution [from;to) for integers, and (from;to) for floating point numbers.</span>
    <span class="lc">/// if boundCheck is false the bounds are included in the floating point number distribution.</span>
    <span class="lc">/// the range for int and long is limited to only half the possible range</span>
    <span class="lc">/// (it could be worked around using long aritmethic for int, and doing a carry by hand for long,</span>
    <span class="lc">/// but I think it is seldomly needed, for int you are better off using long when needed)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">uniformR2</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span>=<span class="e Bool"><span class="k">true</span></span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">from</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span> <span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">to</span></span>&gt;<span class="e Identifier"><span class="i">from</span></span></span>,<span class="e String"><span class="sl">"empy range in uniformR2"</span></span>)</span>;</span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">from</span></span>&gt;<span class="e Div"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">min</span></span>/<span class="e Int"><span class="n">2</span></span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">to</span></span>&lt;<span class="e Div"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">max</span></span>/<span class="e Int"><span class="n">2</span></span></span></span></span>,<span class="e String"><span class="sl">" from..to range too big"</span></span>)</span>;</span>
        }</span></span>
    }</span>
    <span class="k">body</span> <span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">uint</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ulong</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Plus"><span class="e Identifier"><span class="i">from</span></span>+<span class="e Call"><span class="e Identifier"><span class="i">uniformR</span></span>(<span class="i">to</span>-<span class="i">from</span>)</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">char</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">byte</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ubyte</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">short</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ushort</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">d</span>=<span class="e Minus"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>-<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">from</span></span></span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniformR</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">int</span></span>)</span></span>(<span class="i">d</span>)</span>;</span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e Identifier"><span class="i">nV</span></span>+<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">from</span></span></span></span>)</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Plus"><span class="e Identifier"><span class="i">from</span></span>+<span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">to</span></span>-<span class="e Identifier"><span class="i">from</span></span></span>)</span>*<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span></span></span>;</span></span>
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Identifier"><span class="i">from</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Identifier"><span class="i">to</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span></span></span>
                <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">uniformR2</span></span>(<span class="i">from</span>,<span class="i">to</span>)</span>;</span>
            }</span> <span class="k">else</span> <span class="s Compound">{
                <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
            }</span></span>
        }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" unsupported type for uniformR2 distribution"</span></span></span>);</span></span></span></span>
    }</span></span></span></span></span>
    <span class="lc">/// returns a random element of the given array (which must be non empty)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">uniformEl</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span>)</span> <span class="i">arr</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">arr</span></span>.<span class="e Identifier"><span class="i">length</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"array has to be non empty"</span></span>)</span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Call"><span class="e Identifier"><span class="i">uniformR</span></span>(<span class="i">arr</span>.<span class="i">length</span>)</span>]</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// randomizes the given array and returns it (for some types this is potentially</span>
    <span class="lc">/// more efficient, both from the use of random numbers and speedwise)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomizeUniform</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">U</span></span> <span class="i">S</span>:<span class="t Identifier"><span class="i">S</span></span><span class="t Array">[]</span>)</span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span> <span class="i">T</span>;</span></span></span>
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">byte</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">char</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">val</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span> <span class="lc">/// begin without value?</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">rest</span>=<span class="e Int"><span class="n">4</span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                    <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">rest</span></span>!=<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e And"><span class="e Int"><span class="n">0xFFu</span></span>&amp;<span class="e Identifier"><span class="i">val</span></span></span>)</span></span></span>;</span>
                        <span class="s Expression"><span class="e RShiftAssign"><span class="e Identifier"><span class="i">val</span></span>&gt;&gt;=<span class="e Int"><span class="n">8</span></span></span>;</span>
                        <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">rest</span></span></span>;</span>
                    }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">val</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e And"><span class="e Int"><span class="n">0xFFu</span></span>&amp;<span class="e Identifier"><span class="i">val</span></span></span>)</span></span></span>;</span>
                        <span class="s Expression"><span class="e RShiftAssign"><span class="e Identifier"><span class="i">val</span></span>&gt;&gt;=<span class="e Int"><span class="n">8</span></span></span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">rest</span></span>=<span class="e Int"><span class="n">3</span></span></span>;</span>
                    }</span></span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">uint</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>)</span></span></span>;</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ulong</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)
                    <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>)</span></span></span>;</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span>|| <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span>|| <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>) <span class="s Compound">{
                <span class="lc">// optimize more? not so easy with guaranteed full mantissa initialization</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span></span>;</span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" type not supported by randomizeUniform"</span></span></span>);</span></span></span></span></span>
        }</span> <span class="k">else</span> <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">a</span></span>;</span>
    }</span></span></span></span></span>
    
    <span class="lc">/// randomizes the given array and returns it (for some types this is potentially</span>
    <span class="lc">/// more efficient, both from the use of random numbers and speedwise)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomizeUniformR</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>,<span class="o TemplateTypeParam"><span class="i">V</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span>=<span class="e Bool"><span class="k">true</span></span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">V</span></span> <span class="i">to</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span> <span class="s Compound">{ <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>)</span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"empty range"</span></span>)</span>;</span>}</span>
    <span class="k">body</span> <span class="s Compound">{
        <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span> <span class="i">T</span>;</span></span></span>
        <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">V</span></span>:<span class="t Identifier"><span class="i">T</span></span>)</span>,<span class="e Cat"><span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"incompatible a and to type "</span></span>~<span class="e Identifier"><span class="i">U</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>~<span class="e String"><span class="sl">" "</span></span></span>~<span class="e Identifier"><span class="i">V</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>);</span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">U</span></span> <span class="i">S</span>:<span class="t Identifier"><span class="i">S</span></span><span class="t Array">[]</span>)</span>)<span class="s Compound">{
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">uint</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">char</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">byte</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">d</span>=<span class="e Div"><span class="e TypeDotId"><span class="t Integral"><span class="k">uint</span></span>.<span class="i">max</span></span>/<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>,<span class="i">dTo</span>=<span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>)</span>*<span class="e Identifier"><span class="i">d</span></span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
                    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span> % <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>)</span></span></span>;</span>
                    }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                        <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Int"><span class="n">1000</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>) <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                        }</span></span></span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>,<span class="e String"><span class="sl">"this is less probable than 1.e-301, something is wrong with the random number generator"</span></span>)</span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span> % <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>)</span></span></span>;</span>
                    }</span></span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ulong</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">d</span>=<span class="e Div"><span class="e TypeDotId"><span class="t Integral"><span class="k">ulong</span></span>.<span class="i">max</span></span>/<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ulong</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>,<span class="i">dTo</span>=<span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ulong</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>)</span>*<span class="e Identifier"><span class="i">d</span></span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
                    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">el</span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span> % <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ulong</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>)</span></span></span>;</span>
                    }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                        <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Int"><span class="n">1000</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span></span>;</span>
                            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>) <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                        }</span></span></span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>,<span class="e String"><span class="sl">"this is less probable than 1.e-301, something is wrong with the random number generator"</span></span>)</span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">el</span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>% <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">ulong</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>)</span></span></span>;</span>
                    }</span></span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniformR</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="k">cast</span>(<span class="i">T</span>)<span class="i">to</span>)</span></span>;</span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" unsupported type for uniformR distribution"</span></span></span>);</span></span></span></span>
        }</span> <span class="k">else</span> <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniformR</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="k">cast</span>(<span class="i">T</span>)<span class="i">to</span>)</span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">a</span></span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// randomizes the given variable and returns it (for some types this is potentially</span>
    <span class="lc">/// more efficient, both from the use of random numbers and speedwise)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomizeUniformR2</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>,<span class="o TemplateTypeParam"><span class="i">V</span></span>,<span class="o TemplateTypeParam"><span class="i">W</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span>=<span class="e Bool"><span class="k">true</span></span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">V</span></span> <span class="i">from</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">W</span></span> <span class="i">to</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span> <span class="s Compound">{
        <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span> <span class="i">T</span>;</span></span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>)</span>&gt;<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">from</span></span></span>)</span></span>,<span class="e String"><span class="sl">"empy range in uniformR2"</span></span>)</span>;</span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span></span>)<span class="s Compound">{
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">from</span></span>&gt;<span class="e Div"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">min</span></span>/<span class="e Int"><span class="n">2</span></span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">to</span></span>&lt;<span class="e Div"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">max</span></span>/<span class="e Int"><span class="n">2</span></span></span></span></span>,<span class="e String"><span class="sl">" from..to range too big"</span></span>)</span>;</span>
        }</span></span>
    }</span>
    <span class="k">body</span> <span class="s Compound">{
        <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span> <span class="i">T</span>;</span></span></span>
        <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">V</span></span>:<span class="t Identifier"><span class="i">T</span></span>)</span>,<span class="e Cat"><span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"incompatible a and from type "</span></span>~<span class="e Identifier"><span class="i">U</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>~<span class="e String"><span class="sl">" "</span></span></span>~<span class="e Identifier"><span class="i">V</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>);</span>
        <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">W</span></span>:<span class="t Identifier"><span class="i">T</span></span>)</span>,<span class="e Cat"><span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"incompatible a and to type "</span></span>~<span class="e Identifier"><span class="i">U</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>~<span class="e String"><span class="sl">" "</span></span></span>~<span class="e Identifier"><span class="i">W</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>);</span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">U</span></span> <span class="i">S</span>:<span class="t Identifier"><span class="i">S</span></span><span class="t Array">[]</span>)</span>)<span class="s Compound">{
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">uint</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ulong</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">d</span>=<span class="e Minus"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>-<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">from</span></span></span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Plus"><span class="e Identifier"><span class="i">from</span></span>+<span class="e Call"><span class="e TmplInstance"><span class="i">uniformR</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">d</span></span>)</span></span>()</span></span></span>;</span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s If"><span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">char</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">byte</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>)<span class="s Scope"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">d</span>=<span class="e Minus"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>-<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">from</span></span></span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Plus"><span class="e TmplInstance"><span class="i">uniformR</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">d</span></span>)</span></span>+<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">from</span></span></span></span>)</span></span></span>;</span>
                }</span></span></span>
            }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span> || <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">res</span>=<span class="e Plus"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">from</span></span></span>+<span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>-<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">from</span></span></span></span>)</span>*<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span></span></span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">boundCheck</span></span>)<span class="s Compound">{
                        <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">from</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">res</span></span>!=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span></span>)<span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Identifier"><span class="i">res</span></span></span>;</span>
                        }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniformR2</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="k">cast</span>(<span class="i">T</span>)<span class="i">from</span>,<span class="k">cast</span>(<span class="i">T</span>)<span class="i">to</span>)</span></span>;</span>
                        }</span></span></span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Identifier"><span class="i">res</span></span></span>;</span>
                    }</span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" unsupported type for uniformR2 distribution"</span></span></span>);</span></span></span></span></span>
        }</span> <span class="k">else</span> <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniformR2</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="i">from</span>,<span class="i">to</span>)</span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">a</span></span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// randomizes the given variable like uniformRSymm and returns it</span>
    <span class="lc">/// (for some types this is potentially more efficient, both from the use of</span>
    <span class="lc">/// random numbers and speedwise)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomizeUniformRSymm</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>,<span class="o TemplateTypeParam"><span class="i">V</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span>=<span class="e Bool"><span class="k">true</span></span></span>, <span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">excludeZero</span>=<span class="e TmplInstance"><span class="i">isFloat</span>!<span class="o TemplateArguments">(<span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span>)</span></span></span>)</span>
        <span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">V</span></span> <span class="i">to</span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span> <span class="s Compound">{ <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>)</span>&gt;<span class="e Int"><span class="n">0</span></span></span>,<span class="e String"><span class="sl">"empty range"</span></span>)</span>;</span>}</span>
    <span class="k">body</span> <span class="s Compound">{
        <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span> <span class="i">T</span>;</span></span></span>
        <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">V</span></span>:<span class="t Identifier"><span class="i">T</span></span>)</span>,<span class="e Cat"><span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"incompatible a and to type "</span></span>~<span class="e Identifier"><span class="i">U</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>~<span class="e String"><span class="sl">" "</span></span></span>~<span class="e Identifier"><span class="i">V</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>);</span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">U</span></span> <span class="i">S</span>:<span class="t Identifier"><span class="i">S</span></span><span class="t Array">[]</span>)</span>)<span class="s Compound">{
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">int</span></span>)</span>|| <span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">byte</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">d</span>=<span class="e Div"><span class="e TypeDotId"><span class="t Integral"><span class="k">int</span></span>.<span class="i">max</span></span>/<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>,<span class="i">dTo</span>=<span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>)</span>*<span class="e Identifier"><span class="i">d</span></span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span>;</span></span>
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">excludeZero</span></span>)<span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">isIn</span>=<span class="e AndAnd"><span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>&amp;&amp;<span class="e Equal"><span class="e Identifier"><span class="i">nV</span></span>!=<span class="e Int"><span class="n">0</span></span></span></span>;</span></span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">isIn</span>=<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>;</span></span>
                    }</span></span>
                    <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">isIn</span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>% <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>)</span></span></span>;</span>
                    }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                        <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Int"><span class="n">1000</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">next</span></span>()</span></span>;</span>
                            <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>) <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                        }</span></span></span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>,<span class="e String"><span class="sl">"this is less probable than 1.e-301, something is wrong with the random number generator"</span></span>)</span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Paren">(<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>% <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">int</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>)</span></span></span>;</span>
                    }</span></span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">long</span></span>)</span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">long</span></span> <span class="i">d</span>=<span class="e Div"><span class="e TypeDotId"><span class="t Integral"><span class="k">long</span></span>.<span class="i">max</span></span>/<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span>,<span class="i">dTo</span>=<span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">to</span></span></span>)</span>*<span class="e Identifier"><span class="i">d</span></span></span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">long</span></span> <span class="i">nV</span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">long</span></span>)<span class="e Identifier"><span class="i">source</span></span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span>;</span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">excludeZero</span></span>)<span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">isIn</span>=<span class="e AndAnd"><span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>&amp;&amp;<span class="e Equal"><span class="e Identifier"><span class="i">nV</span></span>!=<span class="e Int"><span class="n">0</span></span></span></span>;</span></span>
                    }</span> <span class="k">else</span> <span class="s Compound">{
                        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">isIn</span>=<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span>&amp;&amp;<span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>;</span></span>
                    }</span></span>
                    <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">isIn</span></span>)<span class="s Scope"><span class="s Compound">{
                        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>% <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span></span>;</span>
                    }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s Compound">{
                        <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Int"><span class="n">0</span></span>;</span></span><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span>&lt;<span class="e Int"><span class="n">1000</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Scope"><span class="s Compound">{
                            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">nV</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">nextL</span></span>()</span></span>;</span>
                            <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>) <span class="s Scope"><span class="s Break"><span class="k">break</span>;</span></span></span>
                        }</span></span></span>
                        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&lt;<span class="e Identifier"><span class="i">dTo</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">nV</span></span>&gt;<span class="e Sign">-<span class="e Identifier"><span class="i">dTo</span></span></span></span></span>,<span class="e String"><span class="sl">"this is less probable than 1.e-301, something is wrong with the random number generator"</span></span>)</span>;</span>
                        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Mod"><span class="e Identifier"><span class="i">nV</span></span>% <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Identifier"><span class="i">to</span></span></span></span></span>;</span>
                    }</span></span></span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span></span>||<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span></span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">aPtr</span>=<span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">aPtr</span></span>!=<span class="e Identifier"><span class="i">aEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">aPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">aPtr</span></span></span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniformRSymm</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>,<span class="t Identifier"><span class="i">excludeZero</span></span>)</span></span>(<span class="k">cast</span>(<span class="i">T</span>)<span class="i">to</span>)</span></span>;</span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" unsupported type for uniformRSymm distribution"</span></span></span>);</span></span></span></span>
        }</span> <span class="k">else</span> <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniformRSymm</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>,<span class="t Identifier"><span class="i">excludeZero</span></span>)</span></span>(<span class="k">cast</span>(<span class="i">T</span>)<span class="i">to</span>)</span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">a</span></span>;</span>
    }</span></span></span></span></span>
    
    <span class="lc">/// returns another (mostly indipendent, depending on seed size) random generator</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">RandG</span></span> <span class="i">spawn</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">RandG</span>=<span class="t Identifier"><span class="i">RandomG</span></span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">RandG</span></span> <span class="i">res</span>=<span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RandG</span></span>(<span class="e Bool"><span class="k">false</span></span>)</span>;</span></span>
        <span class="s Synchronized"><span class="k">synchronized</span>(<span class="e This"><span class="k">this</span></span>)<span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">seed</span></span>(&amp;<span class="i">uniform</span>!(<span class="k">uint</span>))</span>;</span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
    }</span></span></span></span></span>
    
    <span class="lc">// ------- structs for uniform distributions -----</span>
    <span class="lc">/// uniform distribution on the whole range for integers, and on (0;1) for floats</span>
    <span class="lc">/// with boundCheck=true this is equivalent to r itself, here just for completness</span>
    <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">UniformDistribution</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span></span>)</span><span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span>;</span>
        <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">UniformDistribution</span></span> <span class="i">create</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">UniformDistribution</span></span> <span class="i">res</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">r</span></span>=<span class="e Identifier"><span class="i">r</span></span></span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
        }</span></span></span>
        <span class="lc">/// chainable call style initialization of variables (thorugh a call to randomize)</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">UniformDistribution</span></span> <span class="i">opCall</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>,<span class="o TemplateTupleParam"><span class="i">S</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">args</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">randomize</span></span>(<span class="i">a</span>,<span class="i">args</span>)</span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
        }</span></span></span></span></span>
        <span class="lc">/// returns a random number</span>
        <span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">getRandom</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>()</span>;</span>
        }</span></span></span>
        <span class="lc">/// initialize el</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomize</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">randomizeUniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="i">a</span>)</span>;</span>
        }</span></span></span></span></span>    
    }</span></span></span></span>

    <span class="lc">/// uniform distribution on the subrange [0;to) for integers, (0;to) for floats</span>
    <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">UniformRDistribution</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span></span>)</span><span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span>;</span>
        <span class="lc">/// initializes the probability distribution</span>
        <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">UniformRDistribution</span></span> <span class="i">create</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">UniformRDistribution</span></span> <span class="i">res</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">r</span></span>=<span class="e Identifier"><span class="i">r</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">to</span></span>=<span class="e Identifier"><span class="i">to</span></span></span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
        }</span></span></span>
        <span class="lc">/// chainable call style initialization of variables (thorugh a call to randomize)</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">UniformRDistribution</span></span> <span class="i">opCall</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">randomize</span></span>(<span class="i">a</span>);</span></span>
            <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
        }</span></span></span></span></span>
        <span class="lc">/// returns a random number</span>
        <span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">getRandom</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniformR</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="i">to</span>)</span>;</span>
        }</span></span></span>
        <span class="lc">/// initialize el</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomize</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">randomizeUniformR</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>,<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="i">a</span>,<span class="i">to</span>)</span>;</span>
        }</span></span></span></span></span>
    }</span></span></span></span>

    <span class="lc">/// uniform distribution on the subrange (-to;to) for integers, (-to;0)u(0;to) for floats</span>
    <span class="lc">/// excludeZero controls if the zero should be excluded, boundCheck if the boundary should</span>
    <span class="lc">/// be excluded for floats</span>
    <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">UniformRSymmDistribution</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span>=<span class="e Bool"><span class="k">true</span></span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">excludeZero</span>=<span class="e TmplInstance"><span class="i">isFloat</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span></span>)</span><span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span>;</span>
        <span class="lc">/// initializes the probability distribution</span>
        <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">UniformRSymmDistribution</span></span> <span class="i">create</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">UniformRSymmDistribution</span></span> <span class="i">res</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">r</span></span>=<span class="e Identifier"><span class="i">r</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">to</span></span>=<span class="e Identifier"><span class="i">to</span></span></span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
        }</span></span></span>
        <span class="lc">/// chainable call style initialization of variables (thorugh a call to randomize)</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">UniformRSymmDistribution</span></span> <span class="i">opCall</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">randomize</span></span>(<span class="i">a</span>);</span></span>
            <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
        }</span></span></span></span></span>
        <span class="lc">/// returns a random number</span>
        <span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">getRandom</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniformRSymm</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>,<span class="t Identifier"><span class="i">excludeZero</span></span>)</span></span>(<span class="i">to</span>)</span>;</span>
        }</span></span></span>
        <span class="lc">/// initialize el</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomize</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">randomizeUniformRSymm</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>,<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="i">a</span>,<span class="i">to</span>)</span>;</span>
        }</span></span></span></span></span>
    }</span></span></span></span>

    <span class="lc">/// uniform distribution on the subrange (-to;to) for integers, (0;to) for floats</span>
    <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">UniformR2Distribution</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>,<span class="o TemplateValueParam"><span class="t Integral"><span class="k">bool</span></span> <span class="i">boundCheck</span></span>)</span><span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">from</span>,<span class="i">to</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span>;</span>
        <span class="lc">/// initializes the probability distribution</span>
        <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">UniformR2Distribution</span></span> <span class="i">create</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">from</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">UniformR2Distribution</span></span> <span class="i">res</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">r</span></span>=<span class="e Identifier"><span class="i">r</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">from</span></span>=<span class="e Identifier"><span class="i">from</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">to</span></span>=<span class="e Identifier"><span class="i">to</span></span></span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
        }</span></span></span>
        <span class="lc">/// chainable call style initialization of variables (thorugh a call to randomize)</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">UniformR2Distribution</span></span> <span class="i">opCall</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>,<span class="o TemplateTupleParam"><span class="i">S</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">args</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">randomize</span></span>(<span class="i">a</span>,<span class="i">args</span>)</span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
        }</span></span></span></span></span>
        <span class="lc">/// returns a random number</span>
        <span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">getRandom</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniformR2</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="i">from</span>,<span class="i">to</span>)</span>;</span>
        }</span></span></span>
        <span class="lc">/// initialize a</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomize</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">randomizeUniformR2</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>,<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">T</span></span>,<span class="t Identifier"><span class="i">boundCheck</span></span>)</span></span>(<span class="i">a</span>,<span class="i">from</span>,<span class="i">to</span>)</span>;</span>
        }</span></span></span></span></span>
    }</span></span></span></span>

    <span class="lc">// ---------- gamma distribution, move to a separate module? --------</span>
    <span class="lc">/// gamma distribution f=x^(alpha-1)*exp(-x/theta)/(gamma(alpha)*theta^alpha)</span>
    <span class="lc">/// alpha has to be bigger than 1, for alpha&lt;1 use gammaD(alpha)=gammaD(alpha+1)*pow(r.uniform!(T),1/alpha)</span>
    <span class="lc">/// from Marsaglia and Tsang, ACM Transaction on Mathematical Software, Vol. 26, N. 3</span>
    <span class="lc">/// 2000, p 363-372</span>
    <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">GammaDistribution</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="d Compound">{
        <span class="d Variables"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">alpha</span>;</span>
        <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">theta</span>;</span>
        <span class="d StorageClass"><span class="k">static</span></span> <span class="d Function"><span class="t Identifier"><span class="i">GammaDistribution</span></span> <span class="i">create</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">r</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">alpha</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">theta</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">GammaDistribution</span></span> <span class="i">res</span>;</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">r</span></span>=<span class="e Identifier"><span class="i">r</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">alpha</span></span>=<span class="e Identifier"><span class="i">alpha</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">res</span></span>.<span class="e Identifier"><span class="i">theta</span></span>=<span class="e Identifier"><span class="i">theta</span></span></span>;</span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">alpha</span></span>&gt;=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>,<span class="e String"><span class="sl">"implemented only for alpha&gt;=1"</span></span>)</span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">res</span></span>;</span>
        }</span></span></span>
        <span class="lc">/// chainable call style initialization of variables (thorugh a call to randomize)</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">GammaDistribution</span></span> <span class="i">opCall</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>,<span class="o TemplateTupleParam"><span class="i">S</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="i">args</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">randomize</span></span>(<span class="i">a</span>,<span class="i">args</span>)</span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
        }</span></span></span></span></span>
        <span class="lc">/// returns a single random number</span>
        <span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">getRandom</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">a</span>=<span class="e Identifier"><span class="i">alpha</span></span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">t</span>=<span class="e Identifier"><span class="i">theta</span></span></span>)</span>
        <span class="s FuncBody"><span class="k">in</span> <span class="s Compound">{ <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">a</span></span>&gt;=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>,<span class="e String"><span class="sl">"implemented only for alpha&gt;=1"</span></span>)</span>;</span> }</span>
        <span class="k">body</span> <span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">d</span>=<span class="e Minus"><span class="e Identifier"><span class="i">a</span></span>-<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">3</span></span></span>)</span></span></span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">c</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Call"><span class="e Identifier"><span class="i">sqrt</span></span>(<span class="i">d</span>*<span class="k">cast</span>(<span class="i">T</span>)<span class="n">9</span>)</span></span>;</span></span>
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">n</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">normalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>()</span>;</span></span>
            <span class="s For"><span class="k">for</span> (;;) <span class="s Scope"><span class="s Compound">{
                <span class="s DoWhile"><span class="k">do</span> <span class="s Scope"><span class="s Compound">{
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">x</span>=<span class="e Call"><span class="e Identifier"><span class="i">n</span></span>.<span class="e Identifier"><span class="i">getRandom</span></span>()</span>;</span></span>
                    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">v</span>=<span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">c</span></span>*<span class="e Identifier"><span class="i">x</span></span></span>+<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>;</span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">v</span></span>=<span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">v</span></span>*<span class="e Identifier"><span class="i">v</span></span></span>*<span class="e Identifier"><span class="i">v</span></span></span></span>;</span> <span class="lc">// might underflow (in extreme situations) so it is in the loop</span>
                }</span></span> <span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">v</span></span>&lt;=<span class="e Int"><span class="n">0</span></span></span>)</span><span class="s Empty">;</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">u</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>()</span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">u</span></span>&lt;<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Float"><span class="n">0.331</span></span></span>)</span>*<span class="e Paren">(<span class="e Mul"><span class="e Identifier"><span class="i">x</span></span>*<span class="e Identifier"><span class="i">x</span></span></span>)</span></span>*<span class="e Paren">(<span class="e Mul"><span class="e Identifier"><span class="i">x</span></span>*<span class="e Identifier"><span class="i">x</span></span></span>)</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">t</span></span>*<span class="e Identifier"><span class="i">d</span></span></span>*<span class="e Identifier"><span class="i">v</span></span></span>;</span></span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Call"><span class="e Identifier"><span class="i">log</span></span>(<span class="i">u</span>)</span>&lt; <span class="e Plus"><span class="e Div"><span class="e Mul"><span class="e Identifier"><span class="i">x</span></span>*<span class="e Identifier"><span class="i">x</span></span></span>/<span class="e Int"><span class="n">2</span></span></span>+<span class="e Mul"><span class="e Identifier"><span class="i">d</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Identifier"><span class="i">v</span></span></span>+<span class="e Call"><span class="e Identifier"><span class="i">log</span></span>(<span class="i">v</span>)</span></span>)</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">t</span></span>*<span class="e Identifier"><span class="i">d</span></span></span>*<span class="e Identifier"><span class="i">v</span></span></span>;</span></span></span>
            }</span></span></span>
        }</span></span></span>
        <span class="lc">/// initializes b with gamma distribued random numbers</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomize</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">b</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">a</span>=<span class="e Identifier"><span class="i">alpha</span></span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">t</span>=<span class="e Identifier"><span class="i">theta</span></span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">U</span></span> <span class="i">S</span>:<span class="t Identifier"><span class="i">S</span></span><span class="t Array">[]</span>)</span>) <span class="s Compound">{
                <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span> <span class="i">T</span>;</span></span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">bEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">bPtr</span>=<span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">bPtr</span></span>!=<span class="e Identifier"><span class="i">bEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">bPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">bPtr</span></span></span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span>) <span class="e Identifier"><span class="i">getRandom</span></span></span>(<span class="i">a</span>,<span class="i">t</span>)</span></span>;</span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">b</span></span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">U</span></span>) <span class="e Identifier"><span class="i">getRandom</span></span></span>(<span class="i">a</span>,<span class="i">t</span>)</span></span>;</span>
            }</span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">b</span></span>;</span>
        }</span></span></span></span></span>
        <span class="lc">/// maps op on random numbers (of type T) and initializes b with it</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomizeOp</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>,<span class="o TemplateTypeParam"><span class="i">S</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">S</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span></span>)</span></span><span class="i">op</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">b</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">a</span>=<span class="e Identifier"><span class="i">alpha</span></span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">t</span>=<span class="e Identifier"><span class="i">theta</span></span></span>)</span><span class="s FuncBody"><span class="s Compound">{
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span>(<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">U</span></span> <span class="i">S</span>:<span class="t Identifier"><span class="i">S</span></span><span class="t Array">[]</span>)</span>)<span class="s Compound">{
                <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span> <span class="i">T</span>;</span></span></span>
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">bEnd</span>=<span class="e Plus"><span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>+<span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
                <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Pointer">*</span> <span class="i">bPtr</span>=<span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">ptr</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">bPtr</span></span>!=<span class="e Identifier"><span class="i">bEnd</span></span></span>;<span class="e PreIncr">++<span class="e Identifier"><span class="i">bPtr</span></span></span>)<span class="s Scope"><span class="s Compound">{
                    <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">bPtr</span></span></span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>)</span></span>)<span class="e Identifier"><span class="i">op</span></span></span>(<span class="i">getRandom</span>(<span class="i">a</span>,<span class="i">t</span>))</span></span>;</span>
                }</span></span></span>
            }</span> <span class="k">else</span> <span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">b</span></span>=<span class="e Call"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">U</span></span>)<span class="e Identifier"><span class="i">op</span></span></span>(<span class="i">getRandom</span>(<span class="i">a</span>))</span></span>;</span>
            }</span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">b</span></span>;</span>
        }</span></span></span></span></span>
    }</span></span></span></span>
    
    <span class="lc">//-------- various distributions available -----------</span>
    
    <span class="lc">/// generators of normal numbers (sigma=1,mu=0) of the given type</span>
    <span class="lc">/// f=exp(-x*x/(2*sigma^2))/(sqrt(2 pi)*sigma)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">NormalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span> <span class="i">normalSource</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span>(<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span>)<span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">normalFloat</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">normalFloat</span></span>=<span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">NormalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="e This"><span class="k">this</span></span>)</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">normalFloat</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span>)<span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">normalDouble</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">normalDouble</span></span>=<span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">NormalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="e This"><span class="k">this</span></span>)</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">normalDouble</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span>)<span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">normalReal</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">normalReal</span></span>=<span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">NormalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="e This"><span class="k">this</span></span>)</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">normalReal</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" no normal source implemented"</span></span></span>);</span></span></span></span>
    }</span></span></span></span></span>

    <span class="lc">/// generators of exp distribued numbers (beta=1) of the given type</span>
    <span class="lc">/// f=1/beta*exp(-x/beta)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">ExpSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span> <span class="i">expSource</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span>(<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">float</span></span>)</span>)<span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">expFloat</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">expFloat</span></span>=<span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">ExpSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="e This"><span class="k">this</span></span>)</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">expFloat</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">double</span></span>)</span>)<span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">expDouble</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">expDouble</span></span>=<span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">ExpSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="e This"><span class="k">this</span></span>)</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">expDouble</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span>==<span class="t Integral"><span class="k">real</span></span>)</span>)<span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">expReal</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">expReal</span></span>=<span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">ExpSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="e This"><span class="k">this</span></span>)</span></span>;</span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">expReal</span></span>;</span>
        }</span> <span class="k">else</span> <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>,<span class="e Cat"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">stringof</span></span>~<span class="e String"><span class="sl">" no exp source implemented"</span></span></span>);</span></span></span></span>
    }</span></span></span></span></span>
    
    <span class="lc">/// generators of normal numbers with a different default sigma/mu</span>
    <span class="lc">/// f=exp(-x*x/(2*sigma^2))/(sqrt(2 pi)*sigma)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">NormalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span>.<span class="t Identifier"><span class="i">NormalDistribution</span></span> <span class="i">normalD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">sigma</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">mu</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Call"><span class="e TmplInstance"><span class="i">normalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>()</span>.<span class="e Identifier"><span class="i">normalD</span></span>(<span class="i">sigma</span>,<span class="i">mu</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// exponential distribued numbers with a different default beta</span>
    <span class="lc">/// f=1/beta*exp(-x/beta)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">ExpSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandomG</span></span>,<span class="t Identifier"><span class="i">T</span></span>)</span></span>.<span class="t Identifier"><span class="i">ExpDistribution</span></span> <span class="i">expD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">beta</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Call"><span class="e TmplInstance"><span class="i">expSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>()</span>.<span class="e Identifier"><span class="i">expD</span></span>(<span class="i">beta</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// gamma distribued numbers with the given default alpha</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">GammaDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span> <span class="i">gammaD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">alpha</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">theta</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">GammaDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>,<span class="i">alpha</span>,<span class="i">theta</span>)</span>;</span>
    }</span></span></span></span></span>

    <span class="lc">/// uniform distribution on the whole integer range, and on (0;1) for floats</span>
    <span class="lc">/// should return simply this??</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">UniformDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>)</span></span> <span class="i">uniformD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">UniformDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution on the whole integer range, and on [0;1] for floats</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">UniformDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span> <span class="i">uniformBoundsD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">UniformDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution [0;to) for ints, (0:to) for reals</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">UniformRDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>)</span></span> <span class="i">uniformRD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">UniformRDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>,<span class="i">to</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution [0;to) for ints, [0:to] for reals</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">UniformRDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span> <span class="i">uniformRBoundsD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">UniformRDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>,<span class="i">to</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution (-to;to) for ints and (-to;0)u(0;to) for reals</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">UniformRSymmDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>,<span class="t TemplateInstance"><span class="i">isFloat</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>)</span></span> <span class="i">uniformRSymmD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">UniformRSymmDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>,<span class="t TemplateInstance"><span class="i">isFloat</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>,<span class="i">to</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution (-to;to) for ints and [-to;0)u(0;to] for reals</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">UniformRSymmDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>,<span class="t TemplateInstance"><span class="i">isFloat</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>)</span></span> <span class="i">uniformRSymmBoundsD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">UniformRSymmDistribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>,<span class="t TemplateInstance"><span class="i">isFloat</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>,<span class="i">to</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution [from;to) for ints and (from;to) for reals</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">UniformR2Distribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>)</span></span> <span class="i">uniformR2D</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">from</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">UniformR2Distribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>,<span class="i">from</span>,<span class="i">to</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// uniform distribution [from;to) for ints and [from;to] for reals</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">UniformR2Distribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span> <span class="i">uniformR2BoundsD</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">from</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">to</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">UniformR2Distribution</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">false</span></span>)</span></span>.<span class="e Identifier"><span class="i">create</span></span>(<span class="k">this</span>,<span class="i">from</span>,<span class="i">to</span>)</span>;</span>
    }</span></span></span></span></span>
    
    <span class="lc">// -------- Utility functions for other distributions -------</span>
    <span class="lc">// add also the corresponding randomize functions?</span>
    
    <span class="lc">/// returns a normal distribued number</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">normal</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">normalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>.<span class="e Identifier"><span class="i">getRandom</span></span>()</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// returns a normal distribued number with the given sigma</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">normalSigma</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">sigma</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">normalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>.<span class="e Identifier"><span class="i">getRandom</span></span>(<span class="i">sigma</span>)</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// returns a normal distribued number with the given sigma and mu</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">normalSigmaMu</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">sigma</span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">mu</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">normalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>.<span class="e Identifier"><span class="i">getRandom</span></span>(<span class="i">sigma</span>,<span class="i">mu</span>)</span>;</span>
    }</span></span></span></span></span>
    
    <span class="lc">/// returns an exp distribued number</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">exp</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">expSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>.<span class="e Identifier"><span class="i">getRandom</span></span>()</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// returns an exp distribued number with the given scale beta</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">expBeta</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">beta</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">expSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>.<span class="e Identifier"><span class="i">getRandom</span></span>(<span class="i">beta</span>)</span>;</span>
    }</span></span></span></span></span>
        
    <span class="lc">/// returns a gamma distribued number</span>
    <span class="lc">/// from Marsaglia and Tsang, ACM Transaction on Mathematical Software, Vol. 26, N. 3</span>
    <span class="lc">/// 2000, p 363-372</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">gamma</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">alpha</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>,<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">sigma</span>=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>)</span>
    <span class="s FuncBody"><span class="k">in</span> <span class="s Compound">{ <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">alpha</span></span>&gt;=<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span>,<span class="e String"><span class="sl">"implemented only for alpha&gt;=1"</span></span>)</span>;</span> }</span>
    <span class="k">body</span> <span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">n</span>=<span class="e TmplInstance"><span class="i">normalSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">d</span>=<span class="e Minus"><span class="e Identifier"><span class="i">alpha</span></span>-<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">3</span></span></span>)</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">c</span>=<span class="e Div"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span>)</span>/<span class="e Call"><span class="e Identifier"><span class="i">sqrt</span></span>(<span class="i">d</span>*<span class="k">cast</span>(<span class="i">T</span>)<span class="n">9</span>)</span></span>;</span></span>
        <span class="s For"><span class="k">for</span> (;;) <span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">x</span>,<span class="i">v</span>;</span></span>
            <span class="s DoWhile"><span class="k">do</span> <span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">x</span></span>=<span class="e Call"><span class="e Identifier"><span class="i">n</span></span>.<span class="e Identifier"><span class="i">getRandom</span></span>()</span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">v</span></span>=<span class="e Plus"><span class="e Mul"><span class="e Identifier"><span class="i">c</span></span>*<span class="e Identifier"><span class="i">x</span></span></span>+<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span></span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">v</span></span>=<span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">v</span></span>*<span class="e Identifier"><span class="i">v</span></span></span>*<span class="e Identifier"><span class="i">v</span></span></span></span>;</span> <span class="lc">// might underflow (in extreme situations) so it is in the loop</span>
            }</span></span> <span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">v</span></span>&lt;=<span class="e Int"><span class="n">0</span></span></span>)</span><span class="s Empty">;</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">u</span>=<span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>()</span>;</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">u</span></span>&lt;<span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Mul"><span class="e Mul"><span class="e Paren">(<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Float"><span class="n">0.331</span></span></span>)</span>*<span class="e Paren">(<span class="e Mul"><span class="e Identifier"><span class="i">x</span></span>*<span class="e Identifier"><span class="i">x</span></span></span>)</span></span>*<span class="e Paren">(<span class="e Mul"><span class="e Identifier"><span class="i">x</span></span>*<span class="e Identifier"><span class="i">x</span></span></span>)</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">sigma</span></span>*<span class="e Identifier"><span class="i">d</span></span></span>*<span class="e Identifier"><span class="i">v</span></span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Call"><span class="e Identifier"><span class="i">log</span></span>(<span class="i">u</span>)</span>&lt; <span class="e Plus"><span class="e Div"><span class="e Mul"><span class="e Identifier"><span class="i">x</span></span>*<span class="e Identifier"><span class="i">x</span></span></span>/<span class="e Int"><span class="n">2</span></span></span>+<span class="e Mul"><span class="e Identifier"><span class="i">d</span></span>*<span class="e Paren">(<span class="e Plus"><span class="e Minus"><span class="e Int"><span class="n">1</span></span>-<span class="e Identifier"><span class="i">v</span></span></span>+<span class="e Call"><span class="e Identifier"><span class="i">log</span></span>(<span class="i">v</span>)</span></span>)</span></span></span></span>) <span class="s Scope"><span class="s Return"><span class="k">return</span> <span class="e Mul"><span class="e Mul"><span class="e Identifier"><span class="i">sigma</span></span>*<span class="e Identifier"><span class="i">d</span></span></span>*<span class="e Identifier"><span class="i">v</span></span></span>;</span></span></span>
        }</span></span></span>
    }</span></span></span></span></span>
    <span class="lc">// ---------------</span>
    
    <span class="lc">/// writes the current status in a string</span>
    <span class="d StorageClass"><span class="k">override</span></span> <span class="d Function"><span class="t Identifier"><span class="i">string</span></span> <span class="i">toString</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>.<span class="e Identifier"><span class="i">idup</span></span>;</span>
    }</span></span></span>
    <span class="lc">/// reads the current status from a string (that should have been trimmed)</span>
    <span class="lc">/// returns the number of chars read</span>
    <span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">fromString</span><span class="o Parameters">(<span class="o Parameter"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span><span class="t Array">[]</span>)</span> <span class="i">s</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">source</span></span>.<span class="e Identifier"><span class="i">fromString</span></span>(<span class="i">s</span>)</span>;</span>
    }</span></span></span>
    
    <span class="lc">// make this by default a uniformRandom number generator</span>
    <span class="lc">/// chainable call style initialization of variables (thorugh a call to randomize)</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">RandomG</span></span> <span class="i">opCall</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">randomize</span></span>(<span class="i">a</span>);</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e This"><span class="k">this</span></span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// returns a random number</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">T</span></span> <span class="i">getRandom</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>,<span class="e Bool"><span class="k">true</span></span>)</span></span>()</span>;</span>
    }</span></span></span></span></span>
    <span class="lc">/// initialize el</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">U</span></span> <span class="i">randomize</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">U</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">U</span></span> <span class="i">a</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TmplInstance"><span class="i">randomizeUniform</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">U</span></span>,<span class="e Bool"><span class="k">true</span></span>)</span></span>(<span class="i">a</span>)</span>;</span>
    }</span></span></span></span></span>
    
}</span></span></span></span> <span class="lc">// end class RandomG</span>

<span class="lc">/// make the default random number generator type</span>
<span class="lc">/// (a non threadsafe random number generator) easily available</span>
<span class="lc">/// you can safely expect a new instance of this to be indipendent from all the others</span>
<span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">RandomG</span>!<span class="o TemplateArguments">()</span></span> <span class="i">Random</span>;</span></span>
<span class="lc">/// default threadsafe random number generator type</span>
<span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">RandomG</span>!<span class="o TemplateArguments">(<span class="t TemplateInstance"><span class="i">Sync</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">DefaultEngine</span></span>)</span></span>)</span></span> <span class="i">RandomSync</span>;</span></span>

<span class="lc">/// shared locked (threadsafe) random number generator</span>
<span class="lc">/// initialized with urandom if available, with time otherwise</span>
<span class="d StorageClass"><span class="k">static</span></span> <span class="d StorageClass"><span class="k">__gshared</span></span> <span class="d Variables"><span class="t Identifier"><span class="i">RandomSync</span></span> <span class="i">rand</span>;</span>
<span class="d StorageClass"><span class="k">shared</span></span> <span class="d StaticCtor"><span class="k">static</span> <span class="k">this</span> ()
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">rand</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">RandomSync</span></span>(<span class="e Bool"><span class="k">false</span></span>)</span></span>;</span>
    <span class="s Version"><span class="k">version</span>(<span class="i">has_urandom</span>)<span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">URandom</span></span> <span class="i">r</span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">rand</span></span>.<span class="e Identifier"><span class="i">seed</span></span>(&amp;<span class="i">r</span>.<span class="i">next</span>)</span>;</span>
    }</span> <span class="k">else</span> <span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">s</span>;</span></span>
        <span class="s Version"><span class="k">version</span> (<span class="i">Posix</span>)<span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">timeval</span></span> <span class="i">tv</span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">gettimeofday</span></span> (&amp;<span class="i">tv</span>, <span class="k">null</span>)</span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">s</span></span> = <span class="e Identifier"><span class="i">tv</span></span>.<span class="e Identifier"><span class="i">tv_usec</span></span></span>;</span>
        }</span> <span class="k">else</span> <span class="s Version"><span class="k">version</span> (<span class="i">Win32</span>) <span class="s Compound">{
             <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">QueryPerformanceCounter</span></span> (&amp;<span class="i">s</span>)</span>;</span>
         }</span></span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Array">[<span class="e Int"><span class="n">2</span></span>]</span> <span class="i">a</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>= <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">s</span></span> &amp; <span class="e Int"><span class="n">0xFFFF_FFFFUL</span></span></span>)</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">1</span></span>]</span>= <span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">uint</span></span>)<span class="e Paren">(<span class="e RShift"><span class="e Identifier"><span class="i">s</span></span>&gt;&gt;<span class="e Int"><span class="n">32</span></span></span>)</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">rand</span></span>.<span class="e Identifier"><span class="i">seed</span></span>(&amp;(<span class="i">ArraySource</span>(<span class="i">a</span>).<span class="i">next</span>))</span>;</span>
    }</span></span>
}</span></span></span>

<span class="d Debug"><span class="k">debug</span>(<span class="i">UnitTest</span>)<span class="d Compound">{
    <span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">engines</span>.<span class="i">KISS</span>;</span>
    <span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">math</span>.<span class="i">random</span>.<span class="i">engines</span>.<span class="i">CMWC</span>;</span>
    <span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">stdc</span>.<span class="i">stdio</span>:<span class="i">printf</span>;</span>
    <span class="d Import"><span class="k">import</span> <span class="i">tango</span>.<span class="i">io</span>.<span class="i">Stdout</span>;</span>

    <span class="lc">/// very simple statistal test, mean within maxOffset, and maximum/minimum at least minmax/maxmin</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">checkMean</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[]</span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">real</span></span> <span class="i">maxmin</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">real</span></span> <span class="i">minmax</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">real</span></span> <span class="i">expectedMean</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">real</span></span> <span class="i">maxOffset</span></span>,<span class="o Parameter"><span class="t Integral"><span class="k">bool</span></span> <span class="i">alwaysPrint</span>=<span class="e Bool"><span class="k">false</span></span></span>,<span class="o Parameter"><span class="t Integral"><span class="k">bool</span></span> <span class="i">checkB</span>=<span class="e Bool"><span class="k">false</span></span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">T</span></span> <span class="i">minV</span>,<span class="i">maxV</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">real</span></span> <span class="i">meanV</span>=<span class="e Float"><span class="n">0.0L</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span>&gt;<span class="e Int"><span class="n">0</span></span></span>)<span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">minV</span></span>=<span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">0</span></span>]</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">maxV</span></span>=<span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">0</span></span>]</span></span>;</span>
            <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">el</span></span></span>;<span class="e Identifier"><span class="i">a</span></span>)<span class="s Scope"><span class="s Compound">{
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e OrOr"><span class="e Not">!<span class="e Identifier"><span class="i">checkB</span></span></span> || <span class="e Paren">(<span class="e AndAnd"><span class="e Rel"><span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">0</span></span></span>&lt;<span class="e Identifier"><span class="i">el</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">el</span></span>&lt;<span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">T</span></span>)<span class="e Int"><span class="n">1</span></span></span></span></span>)</span></span>,<span class="e String"><span class="sl">"el out of bounds"</span></span>)</span>;</span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">el</span></span>&lt;<span class="e Identifier"><span class="i">minV</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">minV</span></span>=<span class="e Identifier"><span class="i">el</span></span></span>;</span></span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">el</span></span>&gt;<span class="e Identifier"><span class="i">maxV</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">maxV</span></span>=<span class="e Identifier"><span class="i">el</span></span></span>;</span></span></span>
                <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">meanV</span></span>+=<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">real</span></span>)<span class="e Identifier"><span class="i">el</span></span></span></span>;</span>
            }</span></span></span>
            <span class="s Expression"><span class="e DivAssign"><span class="e Identifier"><span class="i">meanV</span></span>/=<span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">real</span></span>)<span class="e Identifier"><span class="i">a</span></span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">printM</span>=<span class="e Bool"><span class="k">false</span></span>;</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">real</span></span>)<span class="e Identifier"><span class="i">minV</span></span></span>&gt;<span class="e Identifier"><span class="i">maxmin</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">printM</span></span>=<span class="e Bool"><span class="k">true</span></span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Cast"><span class="k">cast</span>(<span class="t Integral"><span class="k">real</span></span>)<span class="e Identifier"><span class="i">maxV</span></span></span>&lt;<span class="e Identifier"><span class="i">minmax</span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">printM</span></span>=<span class="e Bool"><span class="k">true</span></span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> (<span class="e OrOr"><span class="e Rel"><span class="e Minus"><span class="e Identifier"><span class="i">expectedMean</span></span>-<span class="e Identifier"><span class="i">maxOffset</span></span></span>&gt;<span class="e Identifier"><span class="i">meanV</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">meanV</span></span>&gt;<span class="e Plus"><span class="e Identifier"><span class="i">expectedMean</span></span>+<span class="e Identifier"><span class="i">maxOffset</span></span></span></span></span>) <span class="s Scope"><span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">printM</span></span>=<span class="e Bool"><span class="k">true</span></span></span>;</span></span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">printM</span></span>)<span class="s Scope"><span class="s Compound">{
                <span class="s Version"><span class="k">version</span> (<span class="i">GNU</span>)<span class="s Compound">{
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">printf</span></span>(<span class="sl">"WARNING tango.math.Random statistic is strange: %.*s[%d] %Lg %Lg %Lg<span class="es">\n</span><span class="es">\0</span>"</span>,<span class="k">cast</span>(<span class="k">int</span>)<span class="i">T</span>.<span class="i">stringof</span>.<span class="i">length</span>,<span class="i">T</span>.<span class="i">stringof</span>.<span class="i">ptr</span>,<span class="i">a</span>.<span class="i">length</span>,<span class="k">cast</span>(<span class="k">real</span>)<span class="i">minV</span>,<span class="i">meanV</span>,<span class="k">cast</span>(<span class="k">real</span>)<span class="i">maxV</span>)</span>;</span>
                }</span> <span class="k">else</span> <span class="s Compound">{
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">printf</span></span>(<span class="sl">"WARNING tango.math.Random statistic is strange: %.*s[%d] %Lg %Lg %Lg<span class="es">\n</span><span class="es">\0</span>"</span>,<span class="k">cast</span>(<span class="k">int</span>)<span class="i">T</span>.<span class="i">stringof</span>.<span class="i">length</span>,<span class="i">T</span>.<span class="i">stringof</span>.<span class="i">ptr</span>,<span class="i">a</span>.<span class="i">length</span>,<span class="k">cast</span>(<span class="k">real</span>)<span class="i">minV</span>,<span class="i">meanV</span>,<span class="k">cast</span>(<span class="k">real</span>)<span class="i">maxV</span>)</span>;</span>
                }</span></span>
            }</span></span> <span class="k">else</span> <span class="s Scope"><span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">alwaysPrint</span></span>) <span class="s Scope"><span class="s Compound">{
                <span class="s Version"><span class="k">version</span> (<span class="i">GNU</span>)<span class="s Compound">{
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">printf</span></span>(<span class="sl">"tango.math.Random statistic: %.*s[%d] %Lg %Lg %Lg<span class="es">\n</span><span class="es">\0</span>"</span>,<span class="k">cast</span>(<span class="k">int</span>)<span class="i">T</span>.<span class="i">stringof</span>.<span class="i">length</span>,<span class="i">T</span>.<span class="i">stringof</span>.<span class="i">ptr</span>,<span class="i">a</span>.<span class="i">length</span>,<span class="k">cast</span>(<span class="k">real</span>)<span class="i">minV</span>,<span class="i">meanV</span>,<span class="k">cast</span>(<span class="k">real</span>)<span class="i">maxV</span>)</span>;</span>
                }</span> <span class="k">else</span> <span class="s Compound">{
                    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">printf</span></span>(<span class="sl">"tango.math.Random statistic: %.*s[%d] %Lg %Lg %Lg<span class="es">\n</span><span class="es">\0</span>"</span>,<span class="k">cast</span>(<span class="k">int</span>)<span class="i">T</span>.<span class="i">stringof</span>.<span class="i">length</span>,<span class="i">T</span>.<span class="i">stringof</span>.<span class="i">ptr</span>,<span class="i">a</span>.<span class="i">length</span>,<span class="k">cast</span>(<span class="k">real</span>)<span class="i">minV</span>,<span class="i">meanV</span>,<span class="k">cast</span>(<span class="k">real</span>)<span class="i">maxV</span>)</span>;</span>
                }</span></span>
            }</span></span></span></span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">printM</span></span>;</span>
        }</span></span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Int"><span class="n">0</span></span>)</span>;</span>
    }</span></span></span></span></span>
    
    <span class="lc">/// check a given generator both on the whole array, and on each element separately</span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">doTests</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">RandG</span></span>,<span class="o TemplateTupleParam"><span class="i">Arrays</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">RandG</span></span> <span class="i">r</span></span>,<span class="o Parameter"><span class="t Integral"><span class="k">real</span></span> <span class="i">maxmin</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">real</span></span> <span class="i">minmax</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">real</span></span> <span class="i">expectedMean</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">real</span></span> <span class="i">maxOffset</span></span>,<span class="o Parameter"><span class="t Integral"><span class="k">bool</span></span> <span class="i">alwaysPrint</span></span>,<span class="o Parameter"><span class="t Integral"><span class="k">bool</span></span> <span class="i">checkB</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Arrays</span></span> <span class="i">arrs</span></span>)</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">gFail</span>=<span class="e Bool"><span class="k">false</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>,<span class="o Parameter"><span class="i">TA</span></span></span>;<span class="e Identifier"><span class="i">Arrays</span></span>)<span class="s Scope"><span class="s Compound">{
            <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">BaseTypeOfArrays</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">TA</span></span>)</span></span> <span class="i">T</span>;</span></span></span>
            <span class="lc">// all together</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">r</span></span>(<span class="i">arrs</span><span class="t Array">[<span class="t Identifier"><span class="i">i</span></span>]</span>);</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">fail</span>=<span class="e Call"><span class="e TmplInstance"><span class="i">checkMean</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="i">arrs</span>[<span class="i">i</span>],<span class="i">maxmin</span>,<span class="i">minmax</span>,<span class="i">expectedMean</span>,<span class="i">maxOffset</span>,<span class="i">alwaysPrint</span>,<span class="i">checkB</span>)</span>;</span></span>
            <span class="lc">// one by one</span>
            <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">el</span></span></span>;<span class="e Index"><span class="e Identifier"><span class="i">arrs</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>)<span class="s Scope"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">r</span></span>(<span class="i">el</span>);</span></span>
            }</span></span></span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span> |= <span class="e Call"><span class="e TmplInstance"><span class="i">checkMean</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">T</span></span>)</span></span>(<span class="i">arrs</span>[<span class="i">i</span>],<span class="i">maxmin</span>,<span class="i">minmax</span>,<span class="i">expectedMean</span>,<span class="i">maxOffset</span>,<span class="i">alwaysPrint</span>,<span class="i">checkB</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span> |= <span class="e Identifier"><span class="i">fail</span></span></span>;</span>
        }</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">gFail</span></span>;</span>
    }</span></span></span></span></span>
    
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">testRandSource</span><span class="o TemplateParameters">(<span class="o TemplateTypeParam"><span class="i">RandS</span></span>)</span><span class="o Parameters">()</span><span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">r</span>=<span class="e New"><span class="k">new</span> <span class="t TemplateInstance"><span class="i">RandomG</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">RandS</span></span>)</span></span>()</span>;</span></span>
        <span class="lc">// r.fromString("KISS99_b66dda10_49340130_8f3bf553_224b7afa_00000000_00000000"); // to reproduce a given test...</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span><span class="t Array">[]</span>)</span> <span class="i">initialState</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>;</span></span> <span class="lc">// so that you can reproduce things...</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">allStats</span>=<span class="e Bool"><span class="k">false</span></span>;</span></span> <span class="lc">// set this to true to show all statistics (helpful to track an error)</span>
        <span class="s Try"><span class="k">try</span><span class="s Scope"><span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">uint</span></span>)</span></span>()</span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>()</span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ulong</span></span>)</span></span>()</span>;</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">count</span>=<span class="e Int"><span class="n">10_000</span></span>;</span></span>
            <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span>=<span class="e Identifier"><span class="i">count</span></span>;</span></span><span class="e Equal"><span class="e Identifier"><span class="i">i</span></span>!=<span class="e Int"><span class="n">0</span></span></span>;<span class="e PreDecr">--<span class="e Identifier"><span class="i">i</span></span></span>)<span class="s Scope"><span class="s Compound">{
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">float</span></span> <span class="i">f</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">float</span></span>)</span></span>()</span>;</span></span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Int"><span class="n">0</span></span>&lt;<span class="e Identifier"><span class="i">f</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">f</span></span>&lt;<span class="e Int"><span class="n">1</span></span></span></span>,<span class="e String"><span class="sl">"float out of bounds"</span></span>)</span>;</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span> <span class="i">d</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">double</span></span>)</span></span>()</span>;</span></span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Int"><span class="n">0</span></span>&lt;<span class="e Identifier"><span class="i">d</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">d</span></span>&lt;<span class="e Int"><span class="n">1</span></span></span></span>,<span class="e String"><span class="sl">"double out of bounds"</span></span>)</span>;</span>
                <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">real</span></span> <span class="i">rr</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">real</span></span>)</span></span>()</span>;</span></span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Int"><span class="n">0</span></span>&lt;<span class="e Identifier"><span class="i">rr</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">rr</span></span>&lt;<span class="e Int"><span class="n">1</span></span></span></span>,<span class="e String"><span class="sl">"double out of bounds"</span></span>)</span>;</span>
            }</span></span></span>
            <span class="lc">// checkpoint status (str)</span>
            <span class="s Declaration"><span class="d Variables"><span class="t Const"><span class="k">const</span>(<span class="t Integral"><span class="k">char</span></span><span class="t Array">[]</span>)</span> <span class="i">status</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">toString</span></span>()</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">tVal</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">uint</span></span>)</span></span>()</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span> <span class="i">t2Val</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>()</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ulong</span></span> <span class="i">t3Val</span>=<span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ulong</span></span>)</span></span>()</span>;</span></span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">byte</span></span><span class="t Array">[<span class="e Int"><span class="n">1000</span></span>]</span>  <span class="i">barr</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[<span class="e Int"><span class="n">1000</span></span>]</span> <span class="i">ubarr</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Array">[<span class="e Int"><span class="n">1000</span></span>]</span>  <span class="i">uiarr</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="e Int"><span class="n">1000</span></span>]</span>   <span class="i">iarr</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">float</span></span><span class="t Array">[<span class="e Int"><span class="n">1000</span></span>]</span> <span class="i">farr</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[<span class="e Int"><span class="n">1000</span></span>]</span><span class="i">darr</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">real</span></span><span class="t Array">[<span class="e Int"><span class="n">1000</span></span>]</span>  <span class="i">rarr</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">byte</span></span><span class="t Array">[]</span>  <span class="i">barr2</span>=<span class="e Slice"><span class="e Identifier"><span class="i">barr</span></span>[]</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">ubyte</span></span><span class="t Array">[]</span> <span class="i">ubarr2</span>=<span class="e Slice"><span class="e Identifier"><span class="i">ubarr</span></span>[]</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span><span class="t Array">[]</span>  <span class="i">uiarr2</span>=<span class="e Slice"><span class="e Identifier"><span class="i">uiarr</span></span>[]</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span>   <span class="i">iarr2</span>=<span class="e Slice"><span class="e Identifier"><span class="i">iarr</span></span>[]</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">float</span></span><span class="t Array">[]</span> <span class="i">farr2</span>=<span class="e Slice"><span class="e Identifier"><span class="i">farr</span></span>[]</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span><span class="i">darr2</span>=<span class="e Slice"><span class="e Identifier"><span class="i">darr</span></span>[]</span>;</span></span>
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">real</span></span><span class="t Array">[]</span>  <span class="i">rarr2</span>=<span class="e Slice"><span class="e Identifier"><span class="i">rarr</span></span>[]</span>;</span></span>
            
            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">fail</span>=<span class="e Bool"><span class="k">false</span></span>,<span class="i">gFail</span>=<span class="e Bool"><span class="k">false</span></span>;</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"Uniform"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>,-<span class="n">100.0L</span>,<span class="n">100.0L</span>,<span class="n">0.0L</span>,<span class="n">20.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">barr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>,<span class="n">100.0L</span>,<span class="n">155.0L</span>,<span class="n">127.5L</span>,<span class="n">20.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">ubarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>,<span class="n">0.25L</span>*<span class="k">cast</span>(<span class="k">real</span>)(<span class="k">uint</span>.<span class="i">max</span>),<span class="n">0.75L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">uint</span>.<span class="i">max</span>,
                <span class="n">0.5L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="n">0.2L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">uiarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>,<span class="n">0.5L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">int</span>.<span class="i">min</span>,<span class="n">0.5L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">int</span>.<span class="i">max</span>,
                <span class="n">0.0L</span>,<span class="n">0.2L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">iarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>,<span class="n">0.2L</span>,<span class="n">0.8L</span>,<span class="n">0.5L</span>,<span class="n">0.2L</span>,<span class="i">allStats</span>,<span class="k">true</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with Uniform distribution"</span>)</span>;</span></span></span>

            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"UniformD"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformD</span>!(<span class="k">int</span>)(),-<span class="n">100.0L</span>,<span class="n">100.0L</span>,<span class="n">0.0L</span>,<span class="n">20.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">barr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformD</span>!(<span class="k">int</span>)(),<span class="n">100.0L</span>,<span class="n">155.0L</span>,<span class="n">127.5L</span>,<span class="n">20.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">ubarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformD</span>!(<span class="k">int</span>)(),<span class="n">0.25L</span>*<span class="k">cast</span>(<span class="k">real</span>)(<span class="k">uint</span>.<span class="i">max</span>),<span class="n">0.75L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">uint</span>.<span class="i">max</span>,
                <span class="n">0.5L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="n">0.2L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">uiarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformD</span>!(<span class="k">real</span>)(),<span class="n">0.5L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">int</span>.<span class="i">min</span>,<span class="n">0.5L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">int</span>.<span class="i">max</span>,
                <span class="n">0.0L</span>,<span class="n">0.2L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">iarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformD</span>!(<span class="k">real</span>)(),<span class="n">0.2L</span>,<span class="n">0.8L</span>,<span class="n">0.5L</span>,<span class="n">0.2L</span>,<span class="i">allStats</span>,<span class="k">true</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with UniformD distribution"</span>)</span>;</span></span></span>

            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"UniformBoundsD"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformBoundsD</span>!(<span class="k">int</span>)(),-<span class="n">100.0L</span>,<span class="n">100.0L</span>,<span class="n">0.0L</span>,<span class="n">20.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">barr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformBoundsD</span>!(<span class="k">int</span>)(),<span class="n">100.0L</span>,<span class="n">155.0L</span>,<span class="n">127.5L</span>,<span class="n">20.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">ubarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformBoundsD</span>!(<span class="k">int</span>)(),<span class="n">0.25L</span>*<span class="k">cast</span>(<span class="k">real</span>)(<span class="k">uint</span>.<span class="i">max</span>),<span class="n">0.75L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">uint</span>.<span class="i">max</span>,
                <span class="n">0.5L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="n">0.2L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">uiarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformBoundsD</span>!(<span class="k">int</span>)(),<span class="n">0.5L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">int</span>.<span class="i">min</span>,<span class="n">0.5L</span>*<span class="k">cast</span>(<span class="k">real</span>)<span class="k">int</span>.<span class="i">max</span>,
                <span class="n">0.0L</span>,<span class="n">0.2L</span>*<span class="k">uint</span>.<span class="i">max</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">iarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformBoundsD</span>!(<span class="k">int</span>)(),<span class="n">0.2L</span>,<span class="n">0.8L</span>,<span class="n">0.5L</span>,<span class="n">0.2L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with UniformBoundsD distribution"</span>)</span>;</span></span></span>

            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"UniformRD"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRD</span>(<span class="k">cast</span>(<span class="k">byte</span>)<span class="n">101</span>),<span class="n">25.0L</span>,<span class="n">75.0L</span>,<span class="n">50.0L</span>,<span class="n">15.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">barr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRD</span>(<span class="k">cast</span>(<span class="k">ubyte</span>)<span class="n">201</span>),<span class="n">50.0L</span>,<span class="n">150.0L</span>,<span class="n">100.0L</span>,<span class="n">20.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">ubarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRD</span>(<span class="n">1001u</span>),<span class="n">250.0L</span>,<span class="n">750.0L</span>,<span class="n">500.0L</span>,<span class="n">100.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">uiarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRD</span>(<span class="n">1001</span> ),<span class="n">250.0L</span>,<span class="n">750.0L</span>,<span class="n">500.0L</span>,<span class="n">100.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">iarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRD</span>(<span class="n">1000.0L</span>),<span class="n">250.0L</span>,<span class="n">750.0L</span>,<span class="n">500.0L</span>,<span class="n">100.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRD</span>(<span class="n">1.0L</span>),<span class="n">0.2L</span>,<span class="n">0.8L</span>,<span class="n">0.5L</span>,<span class="n">0.2L</span>,<span class="i">allStats</span>,<span class="k">true</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with uniformRD distribution"</span>)</span>;</span></span></span>
        
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"UniformRBoundsD"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRBoundsD</span>(<span class="k">cast</span>(<span class="k">byte</span>)<span class="n">101</span>),<span class="n">25.0L</span>,<span class="n">75.0L</span>,<span class="n">50.0L</span>,<span class="n">15.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">barr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRBoundsD</span>(<span class="k">cast</span>(<span class="k">ubyte</span>)<span class="n">201</span>),<span class="n">50.0L</span>,<span class="n">150.0L</span>,<span class="n">100.0L</span>,<span class="n">20.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">ubarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRBoundsD</span>(<span class="n">1001u</span>),<span class="n">250.0L</span>,<span class="n">750.0L</span>,<span class="n">500.0L</span>,<span class="n">100.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">uiarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRBoundsD</span>(<span class="n">1001</span> ),<span class="n">250.0L</span>,<span class="n">750.0L</span>,<span class="n">500.0L</span>,<span class="n">100.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">iarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRBoundsD</span>(<span class="n">1000.0L</span>),<span class="n">250.0L</span>,<span class="n">750.0L</span>,<span class="n">500.0L</span>,<span class="n">100.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with uniformRBoundsD distribution"</span>)</span>;</span></span></span>
        
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"Rsymm"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRSymmD</span>!(<span class="k">byte</span>)(<span class="k">cast</span>(<span class="k">byte</span>)<span class="n">100</span>),
                -<span class="n">40.0L</span>,<span class="n">40.0L</span>,<span class="n">0.0L</span>,<span class="n">30.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">barr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRSymmD</span>!(<span class="k">int</span>)(<span class="n">1000</span>),
                -<span class="n">300.0L</span>,<span class="n">300.0L</span>,<span class="n">0.0L</span>,<span class="n">200.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">iarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRSymmD</span>!(<span class="k">real</span>)(<span class="n">1.0L</span>),
                -<span class="n">0.3L</span>,<span class="n">0.3L</span>,<span class="n">0.0L</span>,<span class="n">0.3L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with Rsymm distribution"</span>)</span>;</span></span></span>

            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"RsymmBounds"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRSymmBoundsD</span>!(<span class="k">byte</span>)(<span class="k">cast</span>(<span class="k">byte</span>)<span class="n">100</span>),
                -<span class="n">40.0L</span>,<span class="n">40.0L</span>,<span class="n">0.0L</span>,<span class="n">30.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">barr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRSymmBoundsD</span>!(<span class="k">int</span>)(<span class="n">1000</span>),
                -<span class="n">300.0L</span>,<span class="n">300.0L</span>,<span class="n">0.0L</span>,<span class="n">200.0L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">iarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">uniformRSymmBoundsD</span>!(<span class="k">real</span>)(<span class="n">1.0L</span>),
                -<span class="n">0.3L</span>,<span class="n">0.3L</span>,<span class="n">0.0L</span>,<span class="n">0.3L</span>,<span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with RsymmBounds distribution"</span>)</span>;</span></span></span>
        
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"Norm"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">normalSource</span>!(<span class="k">float</span>)(),-<span class="n">0.5L</span>,<span class="n">0.5L</span>,<span class="n">0.0L</span>,<span class="n">1.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">normalSource</span>!(<span class="k">double</span>)(),-<span class="n">0.5L</span>,<span class="n">0.5L</span>,<span class="n">0.0L</span>,<span class="n">1.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">normalSource</span>!(<span class="k">real</span>)(),-<span class="n">0.5L</span>,<span class="n">0.5L</span>,<span class="n">0.0L</span>,<span class="n">1.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">normalD</span>!(<span class="k">real</span>)(<span class="n">0.5L</span>,<span class="n">5.0L</span>),<span class="n">4.5L</span>,<span class="n">5.5L</span>,<span class="n">5.0L</span>,<span class="n">0.5L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with Normal distribution"</span>)</span>;</span></span></span>
        
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">allStats</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"Exp"</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span></span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">fail</span></span> =<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">expSource</span>!(<span class="k">float</span>)(),<span class="n">0.8L</span>,<span class="n">2.0L</span>,<span class="n">1.0L</span>,<span class="n">1.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">expSource</span>!(<span class="k">double</span>)(),<span class="n">0.8L</span>,<span class="n">2.0L</span>,<span class="n">1.0L</span>,<span class="n">1.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">expSource</span>!(<span class="k">real</span>)(),<span class="n">0.8L</span>,<span class="n">2.0L</span>,<span class="n">1.0L</span>,<span class="n">1.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">fail</span></span>|=<span class="e Call"><span class="e Identifier"><span class="i">doTests</span></span>(<span class="i">r</span>.<span class="i">expD</span>!(<span class="k">real</span>)(<span class="n">5.0L</span>),<span class="n">1.0L</span>,<span class="n">7.0L</span>,<span class="n">5.0L</span>,<span class="n">1.0L</span>,
                <span class="i">allStats</span>,<span class="k">false</span>,<span class="i">farr2</span>,<span class="i">darr2</span>,<span class="i">rarr2</span>)</span></span>;</span>
            <span class="s Expression"><span class="e OrAssign"><span class="e Identifier"><span class="i">gFail</span></span>|=<span class="e Identifier"><span class="i">fail</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">fail</span></span>) <span class="s Scope"><span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="sl">"... with Exp distribution"</span>)</span>;</span></span></span>

            <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">seed</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">seed</span></span>({ <span class="k">return</span> <span class="n">2</span>*(<span class="i">seed</span>++); })</span>;</span>
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">v1</span> = <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">int</span></span>)</span></span>()</span>;</span></span>

            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">seed</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">seed</span></span>({ <span class="k">return</span> <span class="n">2</span>*(<span class="i">seed</span>++); })</span>;</span>
            <span class="s Declaration"><span class="d StorageClass"><span class="k">auto</span></span> <span class="d Variables"><span class="i">v2</span> = <span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">int</span></span>)</span></span>()</span>;</span></span>

            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">v1</span></span> == <span class="e Identifier"><span class="i">v2</span></span></span>, <span class="e Cat"><span class="e String"><span class="sl">"Re-seed failure: "</span></span> ~ <span class="e Identifier"><span class="i">RandS</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>)</span>;</span>

            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">r</span></span>.<span class="t Identifier"><span class="i">fromString</span></span>(<span class="i">status</span>);</span></span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">uint</span></span>)</span></span>()</span>==<span class="e Identifier"><span class="i">tVal</span></span></span>,<span class="e String"><span class="sl">"restoring of status from str failed"</span></span>)</span>;</span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ubyte</span></span>)</span></span>()</span>==<span class="e Identifier"><span class="i">t2Val</span></span></span>,<span class="e String"><span class="sl">"restoring of status from str failed"</span></span>)</span>;</span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">r</span></span>.<span class="e TmplInstance"><span class="i">uniform</span>!<span class="o TemplateArguments">(<span class="t Integral"><span class="k">ulong</span></span>)</span></span>()</span>==<span class="e Identifier"><span class="i">t3Val</span></span></span>,<span class="e String"><span class="sl">"restoring of status from str failed"</span></span>)</span>;</span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Not">!<span class="e Identifier"><span class="i">gFail</span></span></span>,<span class="e String"><span class="sl">"Random.d failure"</span></span>)</span>;</span>
        }</span></span> <span class="s Catch"><span class="k">catch</span>(<span class="o Parameter"><span class="t Identifier"><span class="i">Exception</span></span> <span class="i">e</span></span>) <span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">Stdout</span></span>(<span class="i">initialState</span>)</span>.<span class="e Identifier"><span class="i">newline</span></span>;</span>
            <span class="s Throw"><span class="k">throw</span> <span class="e Identifier"><span class="i">e</span></span>;</span>
        }</span></span></span>
    }</span></span></span></span></span>

    <span class="d Unittest"><span class="k">unittest</span> <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e TmplInstance"><span class="i">testRandSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">Kiss99</span></span>)</span></span>()</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TmplInstance"><span class="i">testRandSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">CMWC_default</span></span>)</span></span>()</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TmplInstance"><span class="i">testRandSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">KissCmwc_default</span></span>)</span></span>()</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TmplInstance"><span class="i">testRandSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">Twister</span></span>)</span></span>()</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TmplInstance"><span class="i">testRandSource</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">DefaultEngine</span></span>)</span></span>()</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TmplInstance"><span class="i">testRandSource</span>!<span class="o TemplateArguments">(<span class="t TemplateInstance"><span class="i">Sync</span>!<span class="o TemplateArguments">(<span class="t Identifier"><span class="i">DefaultEngine</span></span>)</span></span>)</span></span>()</span>;</span>
    }</span></span></span>

}</span></span></span>

</pre></td>
</tr></table>
</body>
</html>