<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<link rel="stylesheet" href="style.css" type="text/css" />
		<title>/Memory.d</title>
	</head>
	<body>

<table id='dcode'><tr><td id='lnum'><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
<span>75</span>
<span>76</span>
<span>77</span>
<span>78</span>
<span>79</span>
<span>80</span>
<span>81</span>
<span>82</span>
<span>83</span>
<span>84</span>
<span>85</span>
<span>86</span>
<span>87</span>
<span>88</span>
<span>89</span>
<span>90</span>
<span>91</span>
<span>92</span>
<span>93</span>
<span>94</span>
<span>95</span>
<span>96</span>
<span>97</span>
<span>98</span>
<span>99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
<span>122</span>
<span>123</span>
<span>124</span>
<span>125</span>
<span>126</span>
<span>127</span>
<span>128</span>
<span>129</span>
<span>130</span>
<span>131</span>
<span>132</span>
<span>133</span>
<span>134</span>
<span>135</span>
<span>136</span>
<span>137</span>
<span>138</span>
<span>139</span>
<span>140</span>
<span>141</span>
<span>142</span>
<span>143</span>
<span>144</span>
<span>145</span>
<span>146</span>
<span>147</span>
<span>148</span>
<span>149</span>
<span>150</span>
<span>151</span>
<span>152</span>
<span>153</span>
<span>154</span>
<span>155</span>
<span>156</span>
<span>157</span>
<span>158</span>
<span>159</span>
<span>160</span>
<span>161</span>
<span>162</span>
<span>163</span>
<span>164</span>
<span>165</span>
<span>166</span>
<span>167</span>
<span>168</span>
<span>169</span>
<span>170</span>
<span>171</span>
<span>172</span>
<span>173</span>
<span>174</span>
<span>175</span>
<span>176</span>
<span>177</span>
<span>178</span>
<span>179</span>
<span>180</span>
<span>181</span>
<span>182</span>
<span>183</span>
<span>184</span>
<span>185</span>
<span>186</span>
<span>187</span>
<span>188</span>
<span>189</span>
<span>190</span>
<span>191</span>
<span>192</span>
<span>193</span>
<span>194</span>
<span>195</span>
<span>196</span>
<span>197</span>
<span>198</span>
<span>199</span>
<span>200</span>
<span>201</span>
<span>202</span>
<span>203</span>
<span>204</span>
<span>205</span>
<span>206</span>
<span>207</span>
<span>208</span>
<span>209</span>
<span>210</span>
<span>211</span>
<span>212</span>
<span>213</span>
<span>214</span>
<span>215</span>
<span>216</span>
<span>217</span>
<span>218</span>
<span>219</span>
<span>220</span>
<span>221</span>
<span>222</span>
<span>223</span>
<span>224</span>
<span>225</span>
<span>226</span>
<span>227</span>
<span>228</span>
<span>229</span>
<span>230</span>
<span>231</span>
<span>232</span>
<span>233</span>
<span>234</span>
<span>235</span>
<span>236</span>
<span>237</span>
<span>238</span>
<span>239</span>
<span>240</span>
<span>241</span>
<span>242</span>
<span>243</span>
<span>244</span>
<span>245</span>
<span>246</span>
<span>247</span>
<span>248</span>
<span>249</span>
<span>250</span>
<span>251</span>
<span>252</span>
<span>253</span>
<span>254</span>
<span>255</span>
<span>256</span>
<span>257</span>
<span>258</span>
<span>259</span>
<span>260</span>
<span>261</span>
<span>262</span>
<span>263</span>
<span>264</span>
<span>265</span>
<span>266</span>
<span>267</span>
<span>268</span>
<span>269</span>
<span>270</span>
<span>271</span>
<span>272</span>
<span>273</span>
<span>274</span>
<span>275</span>
<span>276</span>
<span>277</span>
<span>278</span>
<span>279</span>
<span>280</span>
<span>281</span>
<span>282</span>
<span>283</span>
<span>284</span>
<span>285</span>
<span>286</span>
<span>287</span>
<span>288</span>
<span>289</span>
<span>290</span>
<span>291</span>
<span>292</span>
<span>293</span>
<span>294</span>
<span>295</span>
<span>296</span>
<span>297</span>
<span>298</span>
<span>299</span>
<span>300</span>
<span>301</span>
<span>302</span>
<span>303</span>
<span>304</span>
<span>305</span>
<span>306</span>
<span>307</span>
<span>308</span>
<span>309</span>
<span>310</span>
<span>311</span>
<span>312</span>
<span>313</span>
<span>314</span>
<span>315</span>
<span>316</span>
<span>317</span>
<span>318</span>
</pre></td><td id='code'><pre><span class='com'>/**
 * The memory module provides an interface to the garbage collector and to
 * any other OS or API-level memory management facilities.
 *
 * Copyright: Copyright (C) 2005-2006 Sean Kelly.  All rights reserved.
 * License:   BSD style: $(LICENSE)
 * Authors:   Sean Kelly
 */</span>
<span class='kw2'>module</span> tango.core.Memory;


<span class='kw4'>private</span>
<span class='opr'>{</span>
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_init<span class='opr'>(</span><span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_term<span class='opr'>(</span><span class='opr'>)</span>;

    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_setFinalizer<span class='opr'>(</span> <span class='kw4'>void</span> <span class='opr'>*</span>p <span class='opr'>)</span>;

    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_enable<span class='opr'>(</span><span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_disable<span class='opr'>(</span><span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_collect<span class='opr'>(</span><span class='opr'>)</span>;

    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span><span class='opr'>*</span> gc_malloc<span class='opr'>(</span> <span class='kw4'>size_t</span> sz, <span class='kw4'>bool</span> df <span class='opr'>=</span> <span class='kw2'>false</span> <span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span><span class='opr'>*</span> gc_calloc<span class='opr'>(</span> <span class='kw4'>size_t</span> sz, <span class='kw4'>bool</span> df <span class='opr'>=</span> <span class='kw2'>false</span> <span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span><span class='opr'>*</span> gc_realloc<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p, <span class='kw4'>size_t</span> sz, <span class='kw4'>bool</span> df <span class='opr'>=</span> <span class='kw2'>false</span> <span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_free<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>;

    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>size_t</span> gc_sizeOf<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>size_t</span> gc_capacityOf<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>;

    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_addRoot<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_addRange<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> pbeg, <span class='kw4'>void</span><span class='opr'>*</span> pend <span class='opr'>)</span>;

    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_removeRoot<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_removeRange<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> pbeg, <span class='kw4'>void</span><span class='opr'>*</span> pend <span class='opr'>)</span>;

    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_pin<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>;
    <span class='kw2'>extern</span> <span class='opr'>(</span>C<span class='opr'>)</span> <span class='kw4'>void</span> gc_unpin<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>;
<span class='opr'>}</span>


<span class='com'>/**
 * This struct encapsulates all garbage collection functionality for the D
 * programming language.  Currently, the garbage collector is decided at
 * link time, but this design could adapt to dynamic garbage collector
 * loading with few semantic changes.
 */</span>
<span class='kw4'>struct</span> GC
<span class='opr'>{</span>
    <span class='com'>/**
     * Enables the garbage collector if collections have previously been
     * suspended by a call to disable.  This function is reentrant, and
     * must be called once for every call to disable before the garbage
     * collector is enabled.
     */</span>
    <span class='kw4'>void</span> enable<span class='opr'>(</span><span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_enable<span class='opr'>(</span><span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Disables the garbage collector.  This function is reentrant, but
     * enable must be called once for each call to disable.
     */</span>
    <span class='kw4'>void</span> disable<span class='opr'>(</span><span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_disable<span class='opr'>(</span><span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Begins a full collection.  While the meaning of this may change based
     * on the garbage collector implementation, typical behavior is to scan
     * all stack segments for roots, mark accessible memory blocks as alive,
     * and then to reclaim free space.  This action may need to suspend all
     * running threads for at least part of the collection process.
     */</span>
    <span class='kw4'>void</span> collect<span class='opr'>(</span><span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_collect<span class='opr'>(</span><span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Requests an aligned block of managed memory from the garbage collector.
     * This memory may be deleted at will with a call to free, or it may be
     * discarded and cleaned up automatically during a collection run.  If
     * allocation fails, this function will call onOutOfMemory which is
     * expected to throw an OutOfMemoryException.
     *
     * Params:
     *  sz = The desired allocation size in bytes.
     *  df = True if this memory block should be finalized.
     *
     * Returns:
     *  A reference to the allocated memory or null if insufficient memory
     *  is available.
     *
     * Throws:
     *  OutOfMemoryException on allocation failure.
     */</span>
    <span class='kw4'>void</span><span class='opr'>*</span> malloc<span class='opr'>(</span> <span class='kw4'>size_t</span> sz, <span class='kw4'>bool</span> df <span class='opr'>=</span> <span class='kw2'>false</span> <span class='opr'>)</span>
    <span class='opr'>{</span>
        <span class='kw1'>return</span> gc_malloc<span class='opr'>(</span> sz, df <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Requests an aligned block of managed memory from the garbage collector,
     * which is initialized with all bits set to zero.  This memory may be
     * deleted at will with a call to free, or it may be discarded and cleaned
     * up automatically during a collection run.  If allocation fails, this
     * function will call onOutOfMemory which is expected to throw an
     * OutOfMemoryException.
     *
     * Params:
     *  sz = The desired allocation size in bytes.
     *  df = True if this memory block should be finalized.
     *
     * Returns:
     *  A reference to the allocated memory or null if insufficient memory
     *  is available.
     *
     * Throws:
     *  OutOfMemoryException on allocation failure.
     */</span>
    <span class='kw4'>void</span><span class='opr'>*</span> calloc<span class='opr'>(</span> <span class='kw4'>size_t</span> sz, <span class='kw4'>bool</span> df <span class='opr'>=</span> <span class='kw2'>false</span> <span class='opr'>)</span>
    <span class='opr'>{</span>
        <span class='kw1'>return</span> gc_calloc<span class='opr'>(</span> sz, df <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * If sz is zero, the memory referenced by p will be deallocated as if
     * by a call to free.  A new memory block of size sz will then be
     * allocated as if by a call to malloc, or the implementation may instead
     * resize the memory block in place.  The contents of the new memory block
     * will be the same as the contents of the old memory block, up to the
     * lesser of the new and old sizes.  Note that existing memory will only
     * be freed by realloc if sz is equal to zero.  The garbage collector is
     * otherwise expected to later reclaim the memory block if it is unused.
     * If allocation fails, this function will call onOutOfMemory which is
     * expected to throw an OutOfMemoryException.  If p references memory not
     * originally allocated by this garbage collector, or if it points to the
     * interior of a memory block, no action will be taken.
     *
     * Params:
     *  p  = A pointer to the root of a valid memory block or to null.
     *  sz = The desired allocation size in bytes.
     *  df = True if this memory block should be finalized.
     *
     * Returns:
     *  A reference to the allocated memory on success or null if sz is
     *  zero.  On failure, the original value of p is returned.
     *
     * Throws:
     *  OutOfMemoryException on allocation failure.
     */</span>
    <span class='kw4'>void</span><span class='opr'>*</span> realloc<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p, <span class='kw4'>size_t</span> sz, <span class='kw4'>bool</span> df <span class='opr'>=</span> <span class='kw2'>false</span> <span class='opr'>)</span>
    <span class='opr'>{</span>
        <span class='kw1'>return</span> gc_realloc<span class='opr'>(</span> p, sz, df <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Deallocates the memory references by p.  If p is null, no action
     * occurs.  If p references memory not originally allocated by this
     * garbage collector, or if it points to the interior of a memory block,
     * no action will be taken.
     *
     * Params:
     *  p = A pointer to the root of a valid memory block or to null.
     */</span>
    <span class='kw4'>void</span> free<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_free<span class='opr'>(</span> p <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Determines the allocated size of a memory block, equivalent to
     * the length property for arrays.  If p references memory not originally
     * allocated by this garbage collector, or if it points to the interior
     * of a memory block, zero will be returned.
     *
     * Params:
     *  p = A pointer to the root of a valid memory block or to null.
     *
     * Returns:
     *  The size in bytes of the memory block referenced by p or zero on error.
     */</span>
    <span class='kw4'>size_t</span> sizeOf<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>
    <span class='opr'>{</span>
        <span class='kw1'>return</span> gc_sizeOf<span class='opr'>(</span> p <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Determines the free space including and immediately following the memory
     * block referenced by p.  If p references memory not originally allocated
     * by this garbage collector, or if it points to the interior of a memory
     * block, zero will be returned.  The purpose of this function is to provide
     * a means to determine the maximum number of bytes for which a call to
     * realloc may resize the existing block in place.
     *
     * Params:
     *  p = A pointer to the root of a valid memory block or to null.
     *
     * Returns:
     *  The size in bytes of the memory block referenced by p or zero on error.
     */</span>
    <span class='kw4'>size_t</span> capacityOf<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>
    <span class='opr'>{</span>
        <span class='kw1'>return</span> gc_capacityOf<span class='opr'>(</span> p <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Adds the memory block referenced by p to an internal list of roots to
     * be scanned during a collection.  If p is null, no operation is
     * performed.
     *
     * Params:
     *  p = A pointer to the root of a valid memory block or to null.
     */</span>
    <span class='kw4'>void</span> add<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_addRoot<span class='opr'>(</span> p <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Adds the memory range beginning with pbeg and ending immediately
     * before pend to to an internal list of memory blocks to be scanned
     * during a collection.  If pbeg and pend are null, no operation is
     * performed.
     *
     * Params:
     *  pbeg = A pointer to the a valid memory location or to null.
     *  pend = A pointer to one past the end of a valid memory block,
     *         or null if pbeg is null.
     */</span>
    <span class='kw4'>void</span> add<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> pbeg, <span class='kw4'>void</span><span class='opr'>*</span> pend <span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_addRange<span class='opr'>(</span> pbeg, pend <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Removes the memory block referenced by p from an internal list of roots
     * to be scanned during a collection.  If p is null, no operation is
     * performed.
     *
     *  p = A pointer to the root of a valid memory block or to null.
     */</span>
    <span class='kw4'>void</span> remove<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_removeRoot<span class='opr'>(</span> p <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Removes the memory block range beginning with pbeg and ending
     * immediately before pend from an internal list of roots to be
     * scanned during a collection.  If pbeg and pend were not previously
     * passed to the garbage collector by a call to add, the result is
     * undefined.  If pbeg and pend are null, no operation is performed.
     *
     * Params:
     *  pbeg = A pointer to the a valid memory location or to null.
     *  pend = A pointer to one past the end of a valid memory block,
     *         or null if pbeg is null.
     */</span>
    <span class='kw4'>void</span> remove<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> pbeg, <span class='kw4'>void</span><span class='opr'>*</span> pend <span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_removeRange<span class='opr'>(</span> pbeg, pend <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Ensures that the memory referenced by p will not be moved by the
     * garbage collector.  This function is reentrant, but unpin must be
     * called once for each call to pin.  If p is null, no operation is
     * performed.
     *
     * Params:
     *  p = A pointer to the root of a valid memory block or to null.
     */</span>
    <span class='kw4'>void</span> pin<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_pin<span class='opr'>(</span> p <span class='opr'>)</span>;
    <span class='opr'>}</span>


    <span class='com'>/**
     * Allows the garbage collector to move the memory block referenced
     * by p during a collection, if pin has previously been called with
     * the supplied value of p as a parameter.  This function is reentrant,
     * and must be called once for every call to pin before the garbage
     * collector is free to move this block.
     *
     * Params:
     *  p = A pointer to the root of a valid memory block or to null.
     */</span>
    <span class='kw4'>void</span> unpin<span class='opr'>(</span> <span class='kw4'>void</span><span class='opr'>*</span> p <span class='opr'>)</span>
    <span class='opr'>{</span>
        gc_unpin<span class='opr'>(</span> p <span class='opr'>)</span>;
    <span class='opr'>}</span>
<span class='opr'>}</span>


<span class='com'>/**
 * All GC routines are accessed through this variable.  This is done to
 * follow the established D coding style guidelines and to reduce the
 * impact of future design changes.
 */</span>
GC gc;
</pre></td></tr></table>	</body>
</html>
