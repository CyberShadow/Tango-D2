<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<link rel="stylesheet" href="style.css" type="text/css" />
		<title>/IBuffer.d</title>
	</head>
	<body>

<table id='dcode'><tr><td id='lnum'><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
<span>39</span>
<span>40</span>
<span>41</span>
<span>42</span>
<span>43</span>
<span>44</span>
<span>45</span>
<span>46</span>
<span>47</span>
<span>48</span>
<span>49</span>
<span>50</span>
<span>51</span>
<span>52</span>
<span>53</span>
<span>54</span>
<span>55</span>
<span>56</span>
<span>57</span>
<span>58</span>
<span>59</span>
<span>60</span>
<span>61</span>
<span>62</span>
<span>63</span>
<span>64</span>
<span>65</span>
<span>66</span>
<span>67</span>
<span>68</span>
<span>69</span>
<span>70</span>
<span>71</span>
<span>72</span>
<span>73</span>
<span>74</span>
<span>75</span>
<span>76</span>
<span>77</span>
<span>78</span>
<span>79</span>
<span>80</span>
<span>81</span>
<span>82</span>
<span>83</span>
<span>84</span>
<span>85</span>
<span>86</span>
<span>87</span>
<span>88</span>
<span>89</span>
<span>90</span>
<span>91</span>
<span>92</span>
<span>93</span>
<span>94</span>
<span>95</span>
<span>96</span>
<span>97</span>
<span>98</span>
<span>99</span>
<span>100</span>
<span>101</span>
<span>102</span>
<span>103</span>
<span>104</span>
<span>105</span>
<span>106</span>
<span>107</span>
<span>108</span>
<span>109</span>
<span>110</span>
<span>111</span>
<span>112</span>
<span>113</span>
<span>114</span>
<span>115</span>
<span>116</span>
<span>117</span>
<span>118</span>
<span>119</span>
<span>120</span>
<span>121</span>
<span>122</span>
<span>123</span>
<span>124</span>
<span>125</span>
<span>126</span>
<span>127</span>
<span>128</span>
<span>129</span>
<span>130</span>
<span>131</span>
<span>132</span>
<span>133</span>
<span>134</span>
<span>135</span>
<span>136</span>
<span>137</span>
<span>138</span>
<span>139</span>
<span>140</span>
<span>141</span>
<span>142</span>
<span>143</span>
<span>144</span>
<span>145</span>
<span>146</span>
<span>147</span>
<span>148</span>
<span>149</span>
<span>150</span>
<span>151</span>
<span>152</span>
<span>153</span>
<span>154</span>
<span>155</span>
<span>156</span>
<span>157</span>
<span>158</span>
<span>159</span>
<span>160</span>
<span>161</span>
<span>162</span>
<span>163</span>
<span>164</span>
<span>165</span>
<span>166</span>
<span>167</span>
<span>168</span>
<span>169</span>
<span>170</span>
<span>171</span>
<span>172</span>
<span>173</span>
<span>174</span>
<span>175</span>
<span>176</span>
<span>177</span>
<span>178</span>
<span>179</span>
<span>180</span>
<span>181</span>
<span>182</span>
<span>183</span>
<span>184</span>
<span>185</span>
<span>186</span>
<span>187</span>
<span>188</span>
<span>189</span>
<span>190</span>
<span>191</span>
<span>192</span>
<span>193</span>
<span>194</span>
<span>195</span>
<span>196</span>
<span>197</span>
<span>198</span>
<span>199</span>
<span>200</span>
<span>201</span>
<span>202</span>
<span>203</span>
<span>204</span>
<span>205</span>
<span>206</span>
<span>207</span>
<span>208</span>
<span>209</span>
<span>210</span>
<span>211</span>
<span>212</span>
<span>213</span>
<span>214</span>
<span>215</span>
<span>216</span>
<span>217</span>
<span>218</span>
<span>219</span>
<span>220</span>
<span>221</span>
<span>222</span>
<span>223</span>
<span>224</span>
<span>225</span>
<span>226</span>
<span>227</span>
<span>228</span>
<span>229</span>
<span>230</span>
<span>231</span>
<span>232</span>
<span>233</span>
<span>234</span>
<span>235</span>
<span>236</span>
<span>237</span>
<span>238</span>
<span>239</span>
<span>240</span>
<span>241</span>
<span>242</span>
<span>243</span>
<span>244</span>
<span>245</span>
<span>246</span>
<span>247</span>
<span>248</span>
<span>249</span>
<span>250</span>
<span>251</span>
<span>252</span>
<span>253</span>
<span>254</span>
<span>255</span>
<span>256</span>
<span>257</span>
<span>258</span>
<span>259</span>
<span>260</span>
<span>261</span>
<span>262</span>
<span>263</span>
<span>264</span>
<span>265</span>
<span>266</span>
<span>267</span>
<span>268</span>
<span>269</span>
<span>270</span>
<span>271</span>
<span>272</span>
<span>273</span>
<span>274</span>
<span>275</span>
<span>276</span>
<span>277</span>
<span>278</span>
<span>279</span>
<span>280</span>
<span>281</span>
<span>282</span>
<span>283</span>
<span>284</span>
<span>285</span>
<span>286</span>
<span>287</span>
<span>288</span>
<span>289</span>
<span>290</span>
<span>291</span>
<span>292</span>
<span>293</span>
<span>294</span>
<span>295</span>
<span>296</span>
<span>297</span>
<span>298</span>
<span>299</span>
<span>300</span>
<span>301</span>
<span>302</span>
<span>303</span>
<span>304</span>
<span>305</span>
<span>306</span>
<span>307</span>
<span>308</span>
<span>309</span>
<span>310</span>
<span>311</span>
<span>312</span>
<span>313</span>
<span>314</span>
<span>315</span>
<span>316</span>
<span>317</span>
<span>318</span>
<span>319</span>
<span>320</span>
<span>321</span>
<span>322</span>
<span>323</span>
<span>324</span>
<span>325</span>
<span>326</span>
<span>327</span>
<span>328</span>
<span>329</span>
<span>330</span>
<span>331</span>
<span>332</span>
<span>333</span>
<span>334</span>
<span>335</span>
<span>336</span>
<span>337</span>
<span>338</span>
<span>339</span>
<span>340</span>
<span>341</span>
<span>342</span>
<span>343</span>
<span>344</span>
<span>345</span>
<span>346</span>
<span>347</span>
<span>348</span>
<span>349</span>
<span>350</span>
<span>351</span>
<span>352</span>
<span>353</span>
<span>354</span>
<span>355</span>
<span>356</span>
<span>357</span>
<span>358</span>
<span>359</span>
<span>360</span>
<span>361</span>
<span>362</span>
<span>363</span>
<span>364</span>
<span>365</span>
<span>366</span>
<span>367</span>
<span>368</span>
<span>369</span>
<span>370</span>
<span>371</span>
<span>372</span>
<span>373</span>
<span>374</span>
<span>375</span>
<span>376</span>
<span>377</span>
<span>378</span>
<span>379</span>
<span>380</span>
<span>381</span>
<span>382</span>
<span>383</span>
<span>384</span>
<span>385</span>
<span>386</span>
<span>387</span>
<span>388</span>
<span>389</span>
<span>390</span>
<span>391</span>
<span>392</span>
<span>393</span>
<span>394</span>
<span>395</span>
<span>396</span>
<span>397</span>
<span>398</span>
<span>399</span>
<span>400</span>
<span>401</span>
<span>402</span>
<span>403</span>
<span>404</span>
<span>405</span>
<span>406</span>
<span>407</span>
<span>408</span>
<span>409</span>
<span>410</span>
<span>411</span>
<span>412</span>
<span>413</span>
<span>414</span>
<span>415</span>
<span>416</span>
<span>417</span>
<span>418</span>
<span>419</span>
<span>420</span>
<span>421</span>
<span>422</span>
<span>423</span>
<span>424</span>
<span>425</span>
<span>426</span>
<span>427</span>
<span>428</span>
<span>429</span>
<span>430</span>
<span>431</span>
<span>432</span>
<span>433</span>
<span>434</span>
<span>435</span>
<span>436</span>
<span>437</span>
<span>438</span>
<span>439</span>
<span>440</span>
<span>441</span>
<span>442</span>
<span>443</span>
<span>444</span>
<span>445</span>
<span>446</span>
<span>447</span>
<span>448</span>
<span>449</span>
<span>450</span>
<span>451</span>
<span>452</span>
<span>453</span>
<span>454</span>
<span>455</span>
<span>456</span>
<span>457</span>
<span>458</span>
</pre></td><td id='code'><pre><span class='com'>/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. All rights reserved

        license:        BSD style: $(LICENSE)

        version:        Initial release: March 2004      
        
        author:         Kris

*******************************************************************************/</span>

<span class='kw2'>module</span> tango.io.model.IBuffer;

<span class='kw4'>private</span> <span class='kw2'>import</span> tango.io.model.IConduit;

<span class='com'>/*******************************************************************************

        the central concept is that of a buffer. The buffer acts
        as a queue (line) where items are removed from the front
        and new items are added to the back. Buffers are modeled 
        by this interface, and tango.io.Buffer exposes a concrete 
        implementation.

        buffers can be written to directly, but a Reader and/or
        Writer are typically used to read &amp; write formatted data.
        These readers &amp; writers are bound to a specific buffer;
        often the same buffer. It's also perfectly legitimate to 
        bind multiple writers to the same buffer; they will all
        behave serially as one would expect. The same applies to
        multiple readers on the same buffer. Readers and writers
        support two styles of IO: put/get, and the C++ style &lt;&lt; 
        and &gt;&gt; operators. All such operations can be chained.

        Any class can be made compatable with the reader/writer
        framework by implementing the IReadable and/or IWritable 
        interfaces. Each of these specify just a single method.

        Buffers may also be tokenized. This is handy when one is
        dealing with text input, and/or the content suits a more
        fluid format than most typical readers &amp; writers support.
        Tokens are mapped directly onto buffer content, so there
        is only minor overhead in using them. Tokens can be read
        and written by reader/writers also, using a more relaxed
        set of rules than those applied to integral IO.

        buffers are sometimes memory-only, in which case there
        is nothing left to do when a reader (or tokenizer) hits
        end of buffer conditions. Other buffers are themselves 
        bound to a Conduit. When this is the case, a reader will 
        eventually cause the buffer to reload via its associated 
        conduit. Previous buffer content will thus be lost. The
        same concept is applied to writers, whereby they flush 
        the content of a full buffer to a bound conduit before 
        continuing. 

        conduits provide virtualized access to external content,
        and represent things like files or Internet connections.
        They are just a different kind of stream. Conduits are
        modelled by tango.io.model.IConduit, and implemented via
        classes FileConduit and SocketConduit. Additional kinds
        of conduit are easy to construct: one either subclasses
        tango.io.Conduit, or implements tango.io.model.IConduit. A
        conduit reads and writes from/to a buffer in big chunks
        (typically the entire buffer).
        
*******************************************************************************/</span>

<span class='kw4'>abstract</span> <span class='kw4'>class</span> IBuffer <span class='com'>/// could be an interface, but that causes poor codegen</span>
<span class='opr'>{</span>
        <span class='kw2'>typedef</span> <span class='kw4'>uint</span> <span class='kw2'>delegate</span> <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>*</span> dst, <span class='kw4'>uint</span> count, <span class='kw4'>uint</span> type<span class='opr'>)</span> Converter;

        <span class='kw4'>private</span> <span class='kw2'>typedef</span> <span class='kw4'>byte</span> Style;

        <span class='kw4'>const</span> Style     Mixed  <span class='opr'>=</span> <span class='nbr'>0</span>, 
                        Binary <span class='opr'>=</span> <span class='nbr'>1</span>,
                        Text   <span class='opr'>=</span> <span class='nbr'>2</span>;

        <span class='com'>/***********************************************************************
                
                Return the backing array

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> getContent <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Return a char[] slice of the buffer up to the limit of
                valid content.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> toString <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Set the backing array with all content readable. Writing
                to this will either flush it to an associated conduit, or
                raise an Eof condition. Use IBuffer.clear() to reset the
                content (make it all writable).

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer setValidContent <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> data<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Set the backing array with some content readable. Writing
                to this will either flush it to an associated conduit, or
                raise an Eof condition. Use IBuffer.clear() to reset the
                content (make it all writable).

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer setContent <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> data, <span class='kw4'>uint</span> readable<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Append an array of data into this buffer, and flush to the
                conduit as necessary. Returns a chaining reference if all 
                data was written; throws an IOException indicating eof or 
                eob if not.

                This is often used in lieu of a Writer.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer append <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> content<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Append another buffer to this one, and flush to the
                conduit as necessary. Returns a chaining reference if all 
                data was written; throws an IOException indicating eof or 
                eob if not.

                This is often used in lieu of a Writer.

        ***********************************************************************/</span>

        IBuffer append <span class='opr'>(</span>IBuffer other<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Read a chunk of data from the buffer, loading from the
                conduit as necessary. The requested number of bytes are
                loaded into the buffer, and marked as having been read 
                when the 'eat' parameter is set true. When 'eat' is set
                false, the read position is not adjusted.

                Returns the corresponding buffer slice when successful, 
                or null if there's not enough data available (Eof; Eob).

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> get <span class='opr'>(</span><span class='kw4'>uint</span> size, <span class='kw4'>bool</span> eat <span class='opr'>=</span> <span class='kw2'>true</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Access buffer content

                Params: 
                dst = destination of the content

                Returns:
                return the number of bytes read, which will be less than
                dst.length when the content has been consumed (Eof, Eob)
                and zero thereafter.

                Remarks:
                Fill the provided array with content. We try to satisfy 
                the request from the buffer content, and read directly
                from an attached conduit where more is required.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> get <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> dst<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Exposes the raw data buffer at the current write position, 
                The delegate is provided with a void[] representing space
                available within the buffer at the current write position.

                The delegate should return the approriate number of bytes 
                if it writes valid content, or IConduit.Eof on error.

                Returns whatever the delegate returns.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> write <span class='opr'>(</span><span class='kw4'>uint</span> <span class='kw2'>delegate</span> <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span> writer<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Exposes the raw data buffer at the current read position. The
                delegate is provided with a void[] representing the available
                data, and should return zero to leave the current read position
                intact. 
                
                If the delegate consumes data, it should return the number of 
                bytes consumed; or IConduit.Eof to indicate an error.

                Returns whatever the delegate returns.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> read <span class='opr'>(</span><span class='kw4'>uint</span> <span class='kw2'>delegate</span> <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span> reader<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                If we have some data left after an export, move it to 
                front-of-buffer and set position to be just after the 
                remains. This is for supporting certain conduits which 
                choose to write just the initial portion of a request.
                            
                Limit is set to the amount of data remaining. Position 
                is always reset to zero.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer compress <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Skip ahead by the specified number of bytes, streaming from 
                the associated conduit as necessary.
        
                Can also reverse the read position by 'size' bytes. This may
                be used to support lookahead-type operations.

                Returns true if successful, false otherwise.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>bool</span> skip <span class='opr'>(</span><span class='kw4'>int</span> size<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Support for tokenizing iterators. 
                
                Upon success, the delegate should return the byte-based 
                index of the consumed pattern (tail end of it). Failure
                to match a pattern should be indicated by returning an
                IConduit.Eof

                Each pattern is expected to be stripped of the delimiter.
                An end-of-file condition causes trailing content to be 
                placed into the token. Requests made beyond Eof result
                in empty matches (length == zero).

                Note that additional iterator and/or reader instances
                will stay in lockstep when bound to a common buffer.

                Returns true if a token was isolated, false otherwise.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>bool</span> next <span class='opr'>(</span><span class='kw4'>uint</span> <span class='kw2'>delegate</span> <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Try to fill the available buffer with content from the 
                specified conduit. In particular, we will never ask to 
                read less than 32 bytes. This permits conduit-filters 
                to operate within a known environment.

                Returns the number of bytes read, or throws an underflow
                error if there nowhere to read from
        
        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> fill <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Try to fill the available buffer with content from the 
                specified conduit. In particular, we will never ask to 
                read less than 32 bytes. This permits conduit-filters 
                to operate within a known environment.

                Returns the number of bytes read, or Conduit.Eof
        
        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> fill <span class='opr'>(</span>IConduit conduit<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Write as much of the buffer that the associated conduit
                can consume.

                Returns the number of bytes written, or Conduit.Eof
        
        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> drain <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                flush the contents of this buffer to the related conduit.
                Throws an IOException on premature eof.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer flush <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Reset position and limit to zero.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer clear <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                Truncate the buffer within its extend. Returns true if
                the new 'extent' is valid, false otherwise.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>bool</span> truncate <span class='opr'>(</span><span class='kw4'>uint</span> extent<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                return count of readable bytes remaining in buffer. This is 
                calculated simply as limit() - position()

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> readable <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                Return count of writable bytes available in buffer. This is 
                calculated simply as capacity() - limit()

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> writable <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                returns the limit of readable content within this buffer

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> getLimit <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                returns the total capacity of this buffer

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> getCapacity <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                returns the current position within this buffer

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> getPosition <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************

                make some room in the buffer
                        
        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> makeRoom <span class='opr'>(</span><span class='kw4'>uint</span> space<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Returns the conduit associated with this buffer. Returns 
                null if the buffer is purely memory based; that is, it's
                not backed by some external conduit.

                Buffers do not require a conduit to operate, but it can
                be convenient to associate one. For example, the IReader
                and IWriter classes use this to import/export content as
                necessary.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IConduit getConduit <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                Sets the external conduit associated with this buffer.

                Buffers do not require an external conduit to operate, but 
                it can be convenient to associate one. For example, methods
                read and write use it to import/export content as necessary.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer setConduit <span class='opr'>(</span>IConduit conduit<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
                
                Return style of buffer

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> Style getStyle <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Throw an exception with the provided message

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> error <span class='opr'>(</span><span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> msg<span class='opr'>)</span>;
<span class='opr'>}</span>


<span class='com'>/*******************************************************************************

        Any class implementing IDecoder can be bound to a reader using
        the setDecoder() method.
        
*******************************************************************************/</span>

<span class='kw4'>abstract</span> <span class='kw4'>class</span> AbstractDecoder
<span class='opr'>{</span>       
        <span class='kw2'>alias</span> decoder opCall;

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> type <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> bind <span class='opr'>(</span>IBuffer buffer<span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> decoder <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> src, <span class='kw4'>uint</span> type<span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> decoder <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>*</span> dst, <span class='kw4'>uint</span> bytes, <span class='kw4'>uint</span> type<span class='opr'>)</span>;
<span class='opr'>}</span>


<span class='com'>/*******************************************************************************

        Any class implementing IEncoder can be bound to a writer using
        the bind() method.
        
*******************************************************************************/</span>

<span class='kw4'>abstract</span> <span class='kw4'>class</span> AbstractEncoder
<span class='opr'>{</span>
        <span class='kw2'>alias</span> encoder opCall;

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> type <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> bind <span class='opr'>(</span>IBuffer buffer<span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> encoder <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>*</span> src, <span class='kw4'>uint</span> bytes, <span class='kw4'>uint</span> type<span class='opr'>)</span>;
<span class='opr'>}</span>
</pre></td></tr></table>	</body>
</html>
