<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<link rel="stylesheet" href="style.css" type="text/css" />
		<title>IBuffer.d</title>
	</head>
	<body>

<table id='dcode'><tr><td id='lnum'><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
</pre></td><td id='code'><pre><span class='com'>/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. All rights reserved

        license:        BSD style: $(LICENSE)

        version:        Initial release: March 2004      
        
        author:         Kris

*******************************************************************************/</span>

<span class='kw2'>module</span> tango.io.model.IBuffer;

<span class='kw4'>private</span> <span class='kw2'>import</span> tango.io.model.IConduit;

<span class='com'>/*******************************************************************************

        the central concept is that of a buffer. The buffer acts
        as a queue (line) where items are removed from the front
        and new items are added to the back. Buffers are modeled 
        by this interface, and tango.io.Buffer exposes a concrete 
        implementation.

        buffers can be written to directly, but a Reader and/or
        Writer are typically used to read &amp; write formatted data.
        These readers &amp; writers are bound to a specific buffer;
        often the same buffer. It's also perfectly legitimate to 
        bind multiple writers to the same buffer; they will all
        behave serially as one would expect. The same applies to
        multiple readers on the same buffer. Readers and writers
        support two styles of IO: put/get, and the C++ style &lt;&lt; 
        and &gt;&gt; operators. All such operations can be chained.

        Any class can be made compatable with the reader/writer
        framework by implementing the IReadable and/or IWritable 
        interfaces. Each of these specify just a single method.

        Buffers may also be tokenized. This is handy when one is
        dealing with text input, and/or the content suits a more
        fluid format than most typical readers &amp; writers support.
        Tokens are mapped directly onto buffer content, so there
        is only minor overhead in using them. Tokens can be read
        and written by reader/writers also, using a more relaxed
        set of rules than those applied to integral IO.

        buffers are sometimes memory-only, in which case there
        is nothing left to do when a reader (or tokenizer) hits
        end of buffer conditions. Other buffers are themselves 
        bound to a Conduit. When this is the case, a reader will 
        eventually cause the buffer to reload via its associated 
        conduit. Previous buffer content will thus be lost. The
        same concept is applied to writers, whereby they flush 
        the content of a full buffer to a bound conduit before 
        continuing. 

        conduits provide virtualized access to external content,
        and represent things like files or Internet connections.
        They are just a different kind of stream. Conduits are
        modelled by tango.io.model.IConduit, and implemented via
        classes FileConduit and SocketConduit. Additional kinds
        of conduit are easy to construct: one either subclasses
        tango.io.Conduit, or implements tango.io.model.IConduit. A
        conduit reads and writes from/to a buffer in big chunks
        (typically the entire buffer).
        
*******************************************************************************/</span>

<span class='kw4'>abstract</span> <span class='kw4'>class</span> IBuffer <span class='com'>// could be an interface, but that causes poor codegen</span>
<span class='opr'>{</span>
        <span class='kw2'>typedef</span> <span class='kw4'>uint</span> <span class='kw2'>delegate</span> <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>*</span> dst, <span class='kw4'>uint</span> count, <span class='kw4'>uint</span> type<span class='opr'>)</span> Converter;

        <span class='kw2'>alias</span> append opCall;
        <span class='kw2'>alias</span> flush  opCall;
      
        <span class='kw4'>private</span> <span class='kw2'>typedef</span> <span class='kw4'>byte</span> Style;

        <span class='kw4'>const</span> Style     Mixed  <span class='opr'>=</span> <span class='nbr'>0</span>, 
                        Binary <span class='opr'>=</span> <span class='nbr'>1</span>,
                        Text   <span class='opr'>=</span> <span class='nbr'>2</span>;

        <span class='com'>/***********************************************************************
                
                Return the backing array

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> getContent <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Return a char[] slice of the buffer up to the limit of
                valid content.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> toString <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Set the backing array with all content readable. Writing
                to this will either flush it to an associated conduit, or
                raise an Eof condition. Use IBuffer.clear() to reset the
                content (make it all writable).

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer setValidContent <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> data<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Set the backing array with some content readable. Writing
                to this will either flush it to an associated conduit, or
                raise an Eof condition. Use IBuffer.clear() to reset the
                content (make it all writable).

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer setContent <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> data, <span class='kw4'>uint</span> readable<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Append an array of data into this buffer, and flush to the
                conduit as necessary. Returns a chaining reference if all 
                data was written; throws an IOException indicating eof or 
                eob if not.

                This is often used in lieu of a Writer.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer append <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> content<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Append another buffer to this one, and flush to the
                conduit as necessary. Returns a chaining reference if all 
                data was written; throws an IOException indicating eof or 
                eob if not.

                This is often used in lieu of a Writer.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer append <span class='opr'>(</span>IBuffer other<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Consume content from a producer

                Params:
                dg = the producing delegate, which should itself accept
                a callback for consuming char[] content

                Returns:
                Returns a chaining reference if all content was written. 
                Throws an IOException indicating eof or eob if not.

                Remarks:
                Invokes the provided 

                This is often used in lieu of a Writer, and enables simple
                classes, such as FilePath and Uri, to emit content directly
                into a buffer (thus avoiding potential for heap activity)

                Examples:
                ---
                auto path = new FilePath (somepath);

                path.produce (&amp;buffer.consume);
                ---

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> consume <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> src<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Read a chunk of data from the buffer, loading from the
                conduit as necessary. The requested number of bytes are
                loaded into the buffer, and marked as having been read 
                when the 'eat' parameter is set true. When 'eat' is set
                false, the read position is not adjusted.

                Returns the corresponding buffer slice when successful, 
                or null if there's not enough data available (Eof; Eob).

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> get <span class='opr'>(</span><span class='kw4'>uint</span> size, <span class='kw4'>bool</span> eat <span class='opr'>=</span> <span class='kw2'>true</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Access buffer content

                Params: 
                dst = destination of the content

                Returns:
                return the number of bytes read, which will be less than
                dst.length when the content has been consumed (Eof, Eob)
                and zero thereafter.

                Remarks:
                Fill the provided array with content. We try to satisfy 
                the request from the buffer content, and read directly
                from an attached conduit where more is required.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> get <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> dst<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Exposes the raw data buffer at the current write position, 
                The delegate is provided with a void[] representing space
                available within the buffer at the current write position.

                The delegate should return the approriate number of bytes 
                if it writes valid content, or IConduit.Eof on error.

                Returns whatever the delegate returns.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> write <span class='opr'>(</span><span class='kw4'>uint</span> <span class='kw2'>delegate</span> <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span> writer<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Exposes the raw data buffer at the current read position. The
                delegate is provided with a void[] representing the available
                data, and should return zero to leave the current read position
                intact. 
                
                If the delegate consumes data, it should return the number of 
                bytes consumed; or IConduit.Eof to indicate an error.

                Returns whatever the delegate returns.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> read <span class='opr'>(</span><span class='kw4'>uint</span> <span class='kw2'>delegate</span> <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span> reader<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                If we have some data left after an export, move it to 
                front-of-buffer and set position to be just after the 
                remains. This is for supporting certain conduits which 
                choose to write just the initial portion of a request.
                            
                Limit is set to the amount of data remaining. Position 
                is always reset to zero.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer compress <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Skip ahead by the specified number of bytes, streaming from 
                the associated conduit as necessary.
        
                Can also reverse the read position by 'size' bytes. This may
                be used to support lookahead-type operations.

                Returns true if successful, false otherwise.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>bool</span> skip <span class='opr'>(</span><span class='kw4'>int</span> size<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Support for tokenizing iterators. 
                
                Upon success, the delegate should return the byte-based 
                index of the consumed pattern (tail end of it). Failure
                to match a pattern should be indicated by returning an
                IConduit.Eof

                Each pattern is expected to be stripped of the delimiter.
                An end-of-file condition causes trailing content to be 
                placed into the token. Requests made beyond Eof result
                in empty matches (length == zero).

                Note that additional iterator and/or reader instances
                will stay in lockstep when bound to a common buffer.

                Returns true if a token was isolated, false otherwise.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>bool</span> next <span class='opr'>(</span><span class='kw4'>uint</span> <span class='kw2'>delegate</span> <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Try to fill the available buffer with content from the 
                specified conduit. In particular, we will never ask to 
                read less than 32 bytes. This permits conduit-filters 
                to operate within a known environment.

                Returns the number of bytes read, or throws an underflow
                error if there nowhere to read from
        
        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> fill <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Try to fill the available buffer with content from the 
                specified conduit. In particular, we will never ask to 
                read less than 32 bytes. This permits conduit-filters 
                to operate within a known environment.

                Returns the number of bytes read, or Conduit.Eof
        
        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> fill <span class='opr'>(</span>IConduit conduit<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Write as much of the buffer that the associated conduit
                can consume.

                Returns the number of bytes written, or Conduit.Eof
        
        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> drain <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                flush the contents of this buffer to the related conduit.
                Throws an IOException on premature eof.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer flush <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Reset position and limit to zero.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer clear <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                Truncate the buffer within its extend. Returns true if
                the new 'extent' is valid, false otherwise.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>bool</span> truncate <span class='opr'>(</span><span class='kw4'>uint</span> extent<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                return count of readable bytes remaining in buffer. This is 
                calculated simply as limit() - position()

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> readable <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                Return count of writable bytes available in buffer. This is 
                calculated simply as capacity() - limit()

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> writable <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                returns the limit of readable content within this buffer

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> getLimit <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                returns the total capacity of this buffer

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> getCapacity <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                returns the current position within this buffer

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> getPosition <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************

                make some room in the buffer
                        
        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> makeRoom <span class='opr'>(</span><span class='kw4'>uint</span> space<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Returns the conduit associated with this buffer. Returns 
                null if the buffer is purely memory based; that is, it's
                not backed by some external conduit.

                Buffers do not require a conduit to operate, but it can
                be convenient to associate one. For example, the IReader
                and IWriter classes use this to import/export content as
                necessary.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IConduit getConduit <span class='opr'>(</span><span class='opr'>)</span>;               

        <span class='com'>/***********************************************************************
        
                Sets the external conduit associated with this buffer.

                Buffers do not require an external conduit to operate, but 
                it can be convenient to associate one. For example, methods
                read and write use it to import/export content as necessary.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> IBuffer setConduit <span class='opr'>(</span>IConduit conduit<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
                
                Return style of buffer

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> Style getStyle <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Throw an exception with the provided message

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> error <span class='opr'>(</span><span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> msg<span class='opr'>)</span>;
<span class='opr'>}</span>


<span class='com'>/*******************************************************************************

        Any class implementing IDecoder can be bound to a reader using
        the setDecoder() method.
        
*******************************************************************************/</span>

<span class='kw4'>abstract</span> <span class='kw4'>class</span> AbstractDecoder
<span class='opr'>{</span>       
        <span class='kw2'>alias</span> decoder opCall;

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> type <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> bind <span class='opr'>(</span>IBuffer buffer<span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> decoder <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> src, <span class='kw4'>uint</span> type<span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> decoder <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>*</span> dst, <span class='kw4'>uint</span> bytes, <span class='kw4'>uint</span> type<span class='opr'>)</span>;
<span class='opr'>}</span>


<span class='com'>/*******************************************************************************

        Any class implementing IEncoder can be bound to a writer using
        the bind() method.
        
*******************************************************************************/</span>

<span class='kw4'>abstract</span> <span class='kw4'>class</span> AbstractEncoder
<span class='opr'>{</span>
        <span class='kw2'>alias</span> encoder opCall;

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> type <span class='opr'>(</span><span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> bind <span class='opr'>(</span>IBuffer buffer<span class='opr'>)</span>;

        <span class='kw4'>abstract</span> <span class='kw4'>uint</span> encoder <span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>*</span> src, <span class='kw4'>uint</span> bytes, <span class='kw4'>uint</span> type<span class='opr'>)</span>;
<span class='opr'>}</span>
</pre></td></tr></table>	</body>
</html>
