<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<link rel="stylesheet" href="style.css" type="text/css" />
		<title>MutableCollection.d</title>
	</head>
	<body>

<table id='dcode'><tr><td id='lnum'><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
</pre></td><td id='code'><pre><span class='com'>/*
 File: MutableCollection.d

 Originally written by Doug Lea and released into the public domain. 
 Thanks for the assistance and support of Sun Microsystems Labs, Agorics 
 Inc, Loral, and everyone contributing, testing, and using this code.

 History:
 Date     Who                What
 24Sep95  dl@cs.oswego.edu   Create from collections.d  working file

*/</span>


<span class='kw2'>module</span> tango.store.model.MutableCollection;

<span class='kw4'>private</span> <span class='kw2'>import</span> tango.store.model.Collection;

<span class='kw4'>private</span> <span class='kw2'>import</span> tango.store.model.Iterator;

<span class='com'>/**
 *
 * MutableCollection is the root interface of all mutable collections; i.e.,
 * collections that may have elements dynamically added, removed,
 * and/or replaced in accord with their collection semantics.
 *
 * 
        author: Doug Lea
 * @version 0.93
 *
 * &lt;P&gt; For an introduction to this package see &lt;A HREF=&quot;index.html&quot;&gt; Overview &lt;/A&gt;.
**/</span>


<span class='kw4'>public</span> <span class='kw2'>interface</span> MutableCollectionT<span class='opr'>(</span>T<span class='opr'>)</span> : CollectionT!<span class='opr'>(</span>T<span class='opr'>)</span>
<span class='opr'>{</span>
        <span class='com'>/**
         * All updatable collections maintain a `version number'. The numbering
         * scheme is arbitrary, but is guaranteed to change upon every
         * modification that could possibly affect an elements() enumeration traversal.
         * (This is true at least within the precision of the `int' representation;
         * performing more than 2^32 operations will lead to reuse of version numbers).
         * Versioning
         * &lt;EM&gt;may&lt;/EM&gt; be conservative with respect to `replacement' operations.
         * For the sake of versioning replacements may be considered as
         * removals followed by additions. Thus version numbers may change 
         * even if the old and new  elements are identical.
         * &lt;P&gt;
         * All element() enumerations for Mutable Collections track version
         * numbers, and raise inconsistency exceptions if the enumeration is
         * used (via get()) on a version other than the one generated
         * by the elements() method.
         * &lt;P&gt;
         * You can use versions to check if update operations actually have any effect
         * on observable state.
         * For example, clear() will cause cause a version change only
         * if the collection was previously non-empty.
         * @return the version number
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>int</span> _version<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/**
         * Cause the collection to become empty. 
         * @return condition:
         * &lt;PRE&gt;
         * isEmpty() &amp;&amp;
         * Version change iff !PREV(this).isEmpty();
         * &lt;/PRE&gt;
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>void</span> clear<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/**
         * Exclude all occurrences of the indicated element from the collection. 
         * No effect if element not present.
         * @param element the element to exclude.
         * @return condition: 
         * &lt;PRE&gt;
         * !has(element) &amp;&amp;
         * size() == PREV(this).size() - PREV(this).instances(element) &amp;&amp;
         * no other element changes &amp;&amp;
         * Version change iff PREV(this).has(element)
         * &lt;/PRE&gt;
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>void</span> exclude<span class='opr'>(</span>T element<span class='opr'>)</span>;


        <span class='com'>/**
         * Remove an instance of the indicated element from the collection. 
         * No effect if !has(element)
         * @param element the element to remove
         * @return condition: 
         * &lt;PRE&gt;
         * let occ = max(1, instances(element)) in
         *  size() == PREV(this).size() - occ &amp;&amp;
         *  instances(element) == PREV(this).instances(element) - occ &amp;&amp;
         *  no other element changes &amp;&amp;
         *  version change iff occ == 1
         * &lt;/PRE&gt;
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>void</span> removeOneOf<span class='opr'>(</span>T element<span class='opr'>)</span>;

        <span class='com'>/**
         * Replace an occurrence of oldElement with newElement.
         * No effect if does not hold oldElement or if oldElement.equals(newElement).
         * The operation has a consistent, but slightly special interpretation
         * when applied to Sets. For Sets, because elements occur at
         * most once, if newElement is already included, replacing oldElement with
         * with newElement has the same effect as just removing oldElement.
         * @return condition:
         * &lt;PRE&gt;
         * let int delta = oldElement.equals(newElement)? 0 : 
         *               max(1, PREV(this).instances(oldElement) in
         *  instances(oldElement) == PREV(this).instances(oldElement) - delta &amp;&amp;
         *  instances(newElement) ==  (this instanceof Set) ? 
         *         max(1, PREV(this).instances(oldElement) + delta):
         *                PREV(this).instances(oldElement) + delta) &amp;&amp;
         *  no other element changes &amp;&amp;
         *  Version change iff delta != 0
         * &lt;/PRE&gt;
         * @exception IllegalElementException if has(oldElement) and !canInclude(newElement)
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>void</span> replaceOneOf<span class='opr'>(</span>T oldElement, T newElement<span class='opr'>)</span>;


        <span class='com'>/**
         * Replace all occurrences of oldElement with newElement.
         * No effect if does not hold oldElement or if oldElement.equals(newElement).
         * The operation has a consistent, but slightly special interpretation
         * when applied to Sets. For Sets, because elements occur at
         * most once, if newElement is already included, replacing oldElement with
         * with newElement has the same effect as just removing oldElement.
         * @return condition:
         * &lt;PRE&gt;
         * let int delta = oldElement.equals(newElement)? 0 : 
                           PREV(this).instances(oldElement) in
         *  instances(oldElement) == PREV(this).instances(oldElement) - delta &amp;&amp;
         *  instances(newElement) ==  (this instanceof Set) ? 
         *         max(1, PREV(this).instances(oldElement) + delta):
         *                PREV(this).instances(oldElement) + delta) &amp;&amp;
         *  no other element changes &amp;&amp;
         *  Version change iff delta != 0
         * &lt;/PRE&gt;
         * @exception IllegalElementException if has(oldElement) and !canInclude(newElement)
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>void</span> replaceAllOf<span class='opr'>(</span>T oldElement, T newElement<span class='opr'>)</span>;


        <span class='com'>/**
         * Remove and return an element.  Implementations
         * may strengthen the guarantee about the nature of this element.
         * but in general it is the most convenient or efficient element to remove.
         * &lt;P&gt;
         * Example usage. One way to transfer all elements from 
         * MutableCollection a to MutableBag b is:
         * &lt;PRE&gt;
         * while (!a.empty()) b.add(a.take());
         * &lt;/PRE&gt;
         * @return an element v such that PREV(this).has(v) 
         * and the postconditions of removeOneOf(v) hold.
         * @exception NoSuchElementException iff isEmpty.
        **/</span>

        <span class='kw4'>public</span> T take<span class='opr'>(</span><span class='opr'>)</span>;


        <span class='com'>/**
         * Exclude all occurrences of each element of the Iterator.
         * Behaviorally equivalent to
         * &lt;PRE&gt;
         * while (e.more()) exclude(e.value());
         * @param e the enumeration of elements to exclude.
         * @exception CorruptedIteratorException is propagated if thrown
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>void</span> excludeElements<span class='opr'>(</span>IteratorT!<span class='opr'>(</span>T<span class='opr'>)</span> e<span class='opr'>)</span>;



        <span class='com'>/**
         * Remove an occurrence of each element of the Iterator.
         * Behaviorally equivalent to
         * &lt;PRE&gt;
         * while (e.more()) removeOneOf(e.value());
         * @param e the enumeration of elements to remove.
         * @exception CorruptedIteratorException is propagated if thrown
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>void</span> removeElements<span class='opr'>(</span>IteratorT!<span class='opr'>(</span>T<span class='opr'>)</span> e<span class='opr'>)</span>;
<span class='opr'>}</span>


<span class='kw2'>alias</span> MutableCollectionT!<span class='opr'>(</span><span class='kw3'>Object</span><span class='opr'>)</span> MutableCollection;
</pre></td></tr></table>	</body>
</html>
