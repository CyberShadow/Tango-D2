<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<link rel="stylesheet" href="../../style.css" type="text/css" />
		<title>store/model/Collection.d</title>
	</head>
	<body>

<table id='dcode'><tr><td id='lnum'><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
</pre></td><td id='code'><pre><span class='com'>/*
 File: Collection.d

 Originally written by Doug Lea and released into the public domain. 
 Thanks for the assistance and support of Sun Microsystems Labs, Agorics 
 Inc, Loral, and everyone contributing, testing, and using this code.

 History:
 Date     Who                What
 24Sep95  dl@cs.oswego.edu   Create from collections.d  working file
 14dec95  dl                 Declare as a subinterface of Cloneable
 9Apr97   dl                 made Serializable

*/</span>


<span class='kw2'>module</span> tango.store.model.Collection;

<span class='kw4'>private</span> <span class='kw2'>import</span> tango.store.model.CollectionIterator;
<span class='kw4'>private</span> <span class='kw2'>import</span> tango.store.model.ImplementationCheckable;


<span class='com'>/**
 * Collection is the base interface for most classes in this package.
 *
 * 
        author: Doug Lea
 * @version 0.93
 *
 * &lt;P&gt; For an introduction to this package see &lt;A HREF=&quot;index.html&quot;&gt; Overview &lt;/A&gt;.
 *
**/</span>
<span class='kw4'>public</span> <span class='kw2'>interface</span> CollectionT<span class='opr'>(</span>T<span class='opr'>)</span> : ImplementationCheckable
<span class='opr'>{</span>

        <span class='kw4'>public</span> <span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> toString<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/**
         * public version of java.lang.T.clone
         * All Collections implement clone. But this is a protected method.
         * Duplicate allows public access.
         * @see clone
        **/</span>

        <span class='kw4'>public</span> CollectionT duplicate<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/**
         * Report the number of elements in the CollectionT.
         * No other spurious effects.
         * @return number of elements
        **/</span>
        <span class='kw4'>public</span> <span class='kw4'>int</span> size<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/**
         * Report whether this Collection has no elements.
         * Behaviorally equivalent to &lt;CODE&gt;size() == 0&lt;/CODE&gt;.
         * @return true iff size() == 0
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>bool</span> isEmpty<span class='opr'>(</span><span class='opr'>)</span>;


        <span class='com'>/**
         * Report whether the Collection COULD contain element,
         * i.e., that it is valid with respect to the Collection's
         * element screener if it has one.
         * Always returns false if element == null.
         * A constant function: if canInclude(v) is ever true it is always true.
         * (This property is not in any way enforced however.)
         * No other spurious effects.
         * @return true if non-null and passes element screener check
        **/</span>
        <span class='kw4'>public</span> <span class='kw4'>bool</span> canInclude<span class='opr'>(</span>T element<span class='opr'>)</span>;


        <span class='com'>/**
         * Report the number of occurrences of element in Collection.
         * Always returns 0 if element == null.
         * Otherwise T.equals is used to test for equality.
         * @param element the element to look for
         * @return the number of occurrences (always nonnegative)
        **/</span>
        <span class='kw4'>public</span> <span class='kw4'>int</span> instances<span class='opr'>(</span>T element<span class='opr'>)</span>;

        <span class='com'>/**
         * Report whether the Collection contains element.
         * Behaviorally equivalent to &lt;CODE&gt;instances(element) &amp;gt;= 0&lt;/CODE&gt;.
         * @param element the element to look for
         * @return true iff contains at least one member that is equal to element.
        **/</span>
        <span class='kw4'>public</span> <span class='kw4'>bool</span> contains<span class='opr'>(</span>T element<span class='opr'>)</span>;

        <span class='com'>/**
         * Return an enumeration that may be used to traverse through
         * the elements in the Collection. Standard usage, for some
         * CollectionT c, and some operation `use(T obj)':
         * &lt;PRE&gt;
         * for (Iterator e = c.elements(); e.more(); )
         *   use(e.value());
         * &lt;/PRE&gt;
         * (The values of get very often need to
         * be coerced to types that you know they are.)
         * &lt;P&gt;
         * All Collections return instances
         * of CollectionIterator, that can report the number of remaining
         * elements, and also perform consistency checks so that
         * for MutableCollections, element enumerations may become 
         * invalidated if the Collection is modified during such a traversal
         * (which could in turn cause random effects on the CollectionT.
         * TO prevent this,  CollectionIterators 
         * raise CorruptedIteratorException on attempts to access
         * gets of altered Collections.)
         * Note: Since all Collection implementations are synchronizable,
         * you may be able to guarantee that element traversals will not be
         * corrupted by using the java &lt;CODE&gt;synchronized&lt;/CODE&gt; construct
         * around code blocks that do traversals. (Use with care though,
         * since such constructs can cause deadlock.)
         * &lt;P&gt;
         * Guarantees about the nature of the elements returned by  get of the
         * returned Iterator may vary accross sub-interfaces.
         * In all cases, the enumerations provided by elements() are guaranteed to
         * step through (via get) ALL elements in the Collection.
         * Unless guaranteed otherwise (for example in Seq), elements() enumerations
         * need not have any particular get() ordering so long as they
         * allow traversal of all of the elements. So, for example, two successive
         * calls to element() may produce enumerations with the same
         * elements but different get() orderings.
         * Again, sub-interfaces may provide stronger guarantees. In
         * particular, Seqs produce enumerations with gets in
         * index order, ElementSortedCollections enumerations are in ascending 
         * sorted order, and KeySortedCollections are in ascending order of keys.
         * @return an enumeration e such that
         * &lt;PRE&gt;
         *   e.remaining() == size() &amp;&amp;
         *   foreach (v in e) has(e) 
         * &lt;/PRE&gt;
        **/</span>

        <span class='kw4'>public</span> CollectionIteratorT!<span class='opr'>(</span>T<span class='opr'>)</span> elements<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/**
         * Report whether other has the same element structure as this.
         * That is, whether other is of the same size, and has the same 
         * elements() properties.
         * This is a useful version of equality testing. But is not named
         * `equals' in part because it may not be the version you need.
         * &lt;P&gt;
         * The easiest way to decribe this operation is just to
         * explain how it is interpreted in standard sub-interfaces:
         * &lt;UL&gt;
         *  &lt;LI&gt; Seq and ElementSortedCollection: other.elements() has the 
         *        same order as this.elements().
         *  &lt;LI&gt; Bag: other.elements has the same instances each element as this.
         *  &lt;LI&gt; Set: other.elements has all elements of this
         *  &lt;LI&gt; Map: other has all (key, element) pairs of this.
         *  &lt;LI&gt; KeySortedCollection: other has all (key, element)
         *       pairs as this, and with keys enumerated in the same order as
         *       this.keys().
         *&lt;/UL&gt;
         * @param other, a Collection
         * @return true if considered to have the same size and elements.
        **/</span>

        <span class='kw4'>public</span> <span class='kw4'>bool</span> matches<span class='opr'>(</span>CollectionT other<span class='opr'>)</span>;


<span class='kw4'>version</span> <span class='opr'>(</span>VERBOSE<span class='opr'>)</span>
<span class='opr'>{</span>
        <span class='com'>/**
         * Construct a new Collection that is a clone of self except
         * that it does not include any occurrences of the indicated element.
         * It is NOT an error to exclude a non-existent element.
         *
         * @param element the element to exclude from the new CollectionT
         * @return a new Collection, c, with the matches as this
         * except that !c.has(element).
        **/</span>
        <span class='kw4'>public</span> CollectionT excluding<span class='opr'>(</span>T element<span class='opr'>)</span>;


        <span class='com'>/**
         * Construct a new Collection that is a clone of self except
         * that it does not include an occurrence of the indicated element.
         * It is NOT an error to remove a non-existent element.
         *
         * @param element the element to exclude from the new Collection
         * @return a new Collection, c, with the matches as this
         * except that c.instances(element) == max(0,instances(element)-1)
        **/</span>
        <span class='kw4'>public</span> CollectionT removingOneOf<span class='opr'>(</span>T element<span class='opr'>)</span>;

        <span class='com'>/**
         * Construct a new Collection that is a clone of self except
         * that one occurrence of oldElement is replaced with
         * newElement. 
         * It is NOT an error to replace a non-existent element.
         *
         * @param oldElement the element to replace
         * @param newElement the replacement
         * @return a new Collection, c, with the matches as this, except:
         * &lt;PRE&gt;
         * let int delta = oldElement.equals(newElement)? 0 : 
         *               max(1, this.instances(oldElement) in
         *  c.instances(oldElement) == this.instances(oldElement) - delta &amp;&amp;
         *  c.instances(newElement) ==  (this instanceof Set) ? 
         *         max(1, this.instances(oldElement) + delta):
         *                this.instances(oldElement) + delta) &amp;&amp;
         * &lt;/PRE&gt;
         * @exception IllegalElementException if has(oldElement) and !canInclude(newElement)
        **/</span>
        <span class='kw4'>public</span> CollectionT replacingOneOf<span class='opr'>(</span>T oldElement, T newElement<span class='opr'>)</span>;


        <span class='com'>/**
         * Construct a new Collection that is a clone of self except
         * that all occurrences of oldElement are replaced with
         * newElement. 
         * It is NOT an error to convert a non-existent element.
         *
         * @param oldElement the element to replace
         * @param newElement the replacement
         * @return a new Collection, c, with the matches as this except
         * &lt;PRE&gt;
         * let int delta = oldElement.equals(newElement)? 0 : 
                           instances(oldElement) in
         *  c.instances(oldElement) == this.instances(oldElement) - delta &amp;&amp;
         *  c.instances(newElement) ==  (this instanceof Set) ? 
         *         max(1, this.instances(oldElement) + delta):
         *                this.instances(oldElement) + delta)
         * &lt;/PRE&gt;
         * @exception IllegalElementException if has(oldElement) and !canInclude(newElement)
        **/</span>

        <span class='kw4'>public</span> CollectionT replacingAllOf<span class='opr'>(</span>T oldElement, T newElement<span class='opr'>)</span>;
<span class='opr'>}</span> <span class='com'>// version</span>
<span class='opr'>}</span>


<span class='kw2'>alias</span> CollectionT!<span class='opr'>(</span><span class='kw3'>Object</span><span class='opr'>)</span> Collection;
</pre></td></tr></table>	</body>
</html>
