<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<link rel="stylesheet" href="../style.css" type="text/css" />
		<title>net/SocketListener.d</title>
	</head>
	<body>

<table id='dcode'><tr><td id='lnum'><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
</pre></td><td id='code'><pre><span class='com'>/*******************************************************************************

        copyright:      Copyright (c) 2004 Kris Bell. All rights reserved

        license:        BSD style: $(LICENSE)

        version:        Initial release: June 2004      
        
        author:         Kris

*******************************************************************************/</span>

<span class='kw2'>module</span> tango.net.SocketListener;

<span class='kw4'>private</span> <span class='kw2'>import</span>  tango.core.Thread;

<span class='kw4'>private</span> <span class='kw2'>import</span>  tango.net.Socket;

<span class='kw4'>private</span> <span class='kw2'>import</span>  tango.io.model.IBuffer;

<span class='com'>/******************************************************************************

        Abstract class to asynchronously listen for incoming data on a 
        socket. This can be used with DatagramSocket &amp; MulticastSocket, 
        and might possibly be useful with a basic SocketConduit also.
        Note that DatagramSocket must first be bound to a local network
        address via bind(), and MulticastSocket should first be made a 
        member of a multicast group via its join() method. Note also
        that the underlying thread is not started by the constructor;
        you should do that manually via the start() method.

******************************************************************************/</span>

<span class='kw4'>class</span> SocketListener : Thread, IListener
<span class='opr'>{</span>
        <span class='kw4'>private</span> <span class='kw4'>bool</span>                    quit;
        <span class='kw4'>private</span> IBuffer                 buffer;
        <span class='kw4'>private</span> ISocketReader           reader;
        <span class='kw4'>private</span> <span class='kw4'>int</span>                     limit <span class='opr'>=</span> <span class='nbr'>3</span>;

        <span class='com'>/**********************************************************************
               
                Construct a listener with the requisite arguments. The
                specified buffer is populated via the provided instance
                of ISocketReader before being passed to the notify()
                method. All arguments are required.

        **********************************************************************/</span>

        <span class='kw2'>this</span> <span class='opr'>(</span>ISocketReader reader, IBuffer buffer<span class='opr'>)</span>
        <span class='kw2'>in</span> <span class='opr'>{</span>
           <span class='kw2'>assert</span> <span class='opr'>(</span>reader<span class='opr'>)</span>;
           <span class='kw2'>assert</span> <span class='opr'>(</span>buffer<span class='opr'>)</span>;
           <span class='opr'>}</span>
        <span class='kw2'>body</span>
        <span class='opr'>{</span>
                <span class='kw2'>this</span>.buffer <span class='opr'>=</span> buffer;
                <span class='kw2'>this</span>.reader <span class='opr'>=</span> reader;
        <span class='opr'>}</span>

        <span class='com'>/***********************************************************************
                
                Notification callback invoked whenever the listener has
                anything to report. The buffer will have whatever content
                was available from the read() operation

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> notify <span class='opr'>(</span>IBuffer buffer<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Handle error conditions from the listener thread.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>void</span> exception <span class='opr'>(</span><span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> msg<span class='opr'>)</span>;

        <span class='com'>/**********************************************************************
             
                Cancel this listener. The thread will quit only after the 
                current read() request responds, or is interrrupted.

        **********************************************************************/</span>

        <span class='kw4'>void</span> cancel <span class='opr'>(</span><span class='opr'>)</span>
        <span class='opr'>{</span>
                quit <span class='opr'>=</span> <span class='kw2'>true</span>;
        <span class='opr'>}</span>

        <span class='com'>/**********************************************************************
             
                Set the maximum contiguous number of exceptions this 
                listener will survive. Setting a limit of zero will 
                not survive any errors at all, whereas a limit of two
                will survive as long as two consecutive errors don't 
                arrive back to back.

        **********************************************************************/</span>

        <span class='kw4'>void</span> setErrorLimit <span class='opr'>(</span><span class='kw4'>ushort</span> limit<span class='opr'>)</span>
        <span class='opr'>{</span>
                <span class='kw2'>this</span>.limit <span class='opr'>=</span> limit <span class='opr'>+</span> <span class='nbr'>1</span>;
        <span class='opr'>}</span>

        <span class='com'>/**********************************************************************

                Execution of this thread is typically stalled on the
                read() method belonging to the ISocketReader specified
                during construction. You can invoke cancel() to indicate
                execution should not proceed further, but that will not
                actually interrupt a blocked read() operation.

                Note that exceptions are all directed towards the handler
                implemented by the class instance. 

        **********************************************************************/</span>

        <span class='kw4'>void</span> run <span class='opr'>(</span><span class='opr'>)</span>
        <span class='opr'>{</span>
                <span class='kw4'>int</span> lives <span class='opr'>=</span> limit;

                <span class='kw1'>while</span> <span class='opr'>(</span>lives <span class='opr'>&gt;</span> <span class='nbr'>0</span><span class='opr'>)</span>
                       <span class='kw2'>try</span> <span class='opr'>{</span>
                           <span class='com'>// start with a clean slate</span>
                           buffer.clear <span class='opr'>(</span><span class='opr'>)</span>;

                           <span class='com'>// wait for incoming content</span>
                           <span class='kw4'>auto</span> result <span class='opr'>=</span> reader.read <span class='opr'>(</span>buffer<span class='opr'>)</span>;

                           <span class='com'>// time to quit? Note that a v0.95 compiler bug </span>
                           <span class='com'>// prohibits 'break' from exiting the try{} block</span>
<span class='com'>//                         if (quit || Socket.isHalting ())</span>
                           <span class='kw1'>if</span> <span class='opr'>(</span>quit || 
                              <span class='opr'>(</span>result <span class='kw2'>is</span> Socket.Eof &amp;&amp; !reader.isAlive<span class='opr'>)</span><span class='opr'>)</span>
                               lives <span class='opr'>=</span> <span class='nbr'>0</span>;
                           <span class='kw1'>else</span>
                              <span class='opr'>{</span>
                              <span class='com'>// invoke callback                        </span>
                              notify <span class='opr'>(</span>buffer<span class='opr'>)</span>;
                              lives <span class='opr'>=</span> limit;
                              <span class='opr'>}</span>
                           <span class='opr'>}</span> <span class='kw2'>catch</span> <span class='opr'>(</span><span class='kw3'>Object</span> x<span class='opr'>)</span>
                                    <span class='com'>// time to quit?</span>
<span class='com'>//                                    if (quit || Socket.isHalting ())</span>
                                    <span class='kw1'>if</span> <span class='opr'>(</span>quit || !reader.isAlive<span class='opr'>)</span>
                                        <span class='kw1'>break</span>;
                                    <span class='kw1'>else</span>
                                       <span class='opr'>{</span>
                                       exception <span class='opr'>(</span>x.toString<span class='opr'>)</span>;
                                       <span class='kw1'>if</span> <span class='opr'>(</span><span class='opr'>-</span><span class='opr'>-</span>lives <span class='kw2'>is</span> <span class='nbr'>0</span><span class='opr'>)</span>
                                           exception <span class='opr'>(</span><span class='str'>&quot;listener thread aborting&quot;</span><span class='opr'>)</span>;
                                       <span class='opr'>}</span>
        <span class='opr'>}</span>
<span class='opr'>}</span>



</pre></td></tr></table>	</body>
</html>
