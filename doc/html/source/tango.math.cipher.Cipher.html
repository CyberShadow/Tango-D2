<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<link rel="stylesheet" href="../../style.css" type="text/css" />
		<title>math/cipher/Cipher.d</title>
	</head>
	<body>

<table id='dcode'><tr><td id='lnum'><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
</pre></td><td id='code'><pre><span class='com'>/*******************************************************************************

        copyright:      Copyright (c) 2004 Regan Heath. All rights reserved

        license:        BSD style: see doc/license.txt for details
      
        version:        Initial release: Feb 2006
        
        author:         Regan Heath, Kris

        This module defines two abstract base classes, the primary one being
        Cipher which can be extended to provide concrete implementations of 
        various ciphers (AKA hashing functions or algorithms). These ciphers
        produce digests (AKA hashes) hence the second abstract base class 
        Digest. In addition CipherException is defined for exception 
        handling.

*******************************************************************************/</span>

<span class='kw2'>module</span> tango.math.cipher.Cipher;

<span class='kw4'>private</span> <span class='kw2'>import</span> tango.core.ByteSwap;

<span class='com'>/*******************************************************************************

       This is an exception class to be thrown by Cipher's where required.
       
*******************************************************************************/</span>

<span class='kw4'>class</span> CipherException : Exception
<span class='opr'>{</span>
        <span class='com'>/***********************************************************************
        
                Construct a CipherException.

                Params: 
                msg = the exception text
                
                Remarks:
                Constructs a CipherException.

        ***********************************************************************/</span>

        <span class='kw2'>this</span><span class='opr'>(</span><span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> msg<span class='opr'>)</span> <span class='opr'>{</span> <span class='kw2'>super</span><span class='opr'>(</span>msg<span class='opr'>)</span>; <span class='opr'>}</span>
<span class='opr'>}</span>


<span class='com'>/*******************************************************************************

       This is the abstract base class for creating custom Digests.
       
*******************************************************************************/</span>

<span class='kw4'>class</span> Digest
<span class='opr'>{</span>
        <span class='com'>/***********************************************************************
        
                Return the string representation

                Returns:
                the digest in string form

                Remarks:
                Formats the digest into hex encoded string form.

        ***********************************************************************/</span>

        <span class='kw4'>abstract</span> <span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> toString<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Return the binary representation

                Returns:
                the digest in binary form

                Remarks:
                Returns a void[] containing the binary representation of the digest.

        ***********************************************************************/</span>
        
        <span class='kw4'>abstract</span> <span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> toBinary<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Represent an array as a hex encoded string

                Params: 
                d = the array to represent

                Returns:
                the string representation

                Remarks:
                Represents any sized array of any sized numerical items as a 
                hex encoded string.

        ***********************************************************************/</span>

        <span class='kw4'>protected</span> <span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> toHexString <span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> src<span class='opr'>)</span> 
        <span class='opr'>{</span>
                <span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> result;
                <span class='kw4'>static</span> <span class='kw4'>char</span><span class='opr'>[</span><span class='opr'>]</span> hexdigits <span class='opr'>=</span> <span class='str'>&quot;0123456789ABCDEF&quot;</span>;

                <span class='kw1'>if</span> <span class='opr'>(</span>src.length<span class='opr'>)</span> 
                   <span class='opr'>{</span>
                   <span class='kw4'>uint</span> index <span class='opr'>=</span> <span class='opr'>-</span><span class='nbr'>1</span>;
                   result <span class='opr'>=</span> <span class='kw2'>new</span> <span class='kw4'>char</span> <span class='opr'>[</span>src.length <span class='opr'>*</span> <span class='nbr'>2</span><span class='opr'>]</span>;
                   <span class='kw1'>foreach</span> <span class='opr'>(</span>b; src<span class='opr'>)</span>
                           <span class='opr'>{</span>
                           result <span class='opr'>[</span><span class='opr'>+</span><span class='opr'>+</span>index<span class='opr'>]</span> <span class='opr'>=</span> hexdigits <span class='opr'>[</span>b <span class='opr'>&gt;</span><span class='opr'>&gt;</span> <span class='nbr'>4</span><span class='opr'>]</span>;
                           result <span class='opr'>[</span><span class='opr'>+</span><span class='opr'>+</span>index<span class='opr'>]</span> <span class='opr'>=</span> hexdigits <span class='opr'>[</span>b <span class='opr'>&amp;</span> <span class='nbr'>0</span>x0f<span class='opr'>]</span>;
                           <span class='opr'>}</span>
                   <span class='opr'>}</span>

                <span class='kw1'>return</span> result;
        <span class='opr'>}</span>
<span class='opr'>}</span>

<span class='com'>/*******************************************************************************

        The interface for Cipher consists of four main public methods and two
        usage patterns.
        
        The first and simplest usage pattern is to call sum() on the complete 
        set of data, the cipher is performed immediately and a Digest is 
        produced. For example:
        ---
        // create an MD5 cipher
        Md5Cipher cipher = new Md5Cipher();
        
        // process the data and produce a digest
        Md5Digest digest = cipher.sum(&quot;The quick brown fox jumps over the lazy dog&quot;);
        ---
        
        The second usage pattern involves three methods and can be used to 
        process the data piece by piece (this makes it useful for cases 
        involving streams of data). It begins with a new Cipher or a call to
        start() which initializes the cipher. Data is ciphered by one or more 
        calls to update(), and finish() is called to complete the process and
        produce a Digest. For example:
        ---
        // create an MD5 cipher
        Md5Cipher cipher = new Md5Cipher();
        
        // process some data
        cipher.update(&quot;The quick brown fox&quot;);
        
        // process some more data
        cipher.update(&quot; jumps over the lazy dog&quot;);
        
        // conclude cipher and produce digest
        Md5Digest digest = cipher.finish()
        ---
        
        When extending Cipher to create a custom cipher you will be required
        to implement a number of abstract methods, these include:
        ---
        public abstract Digest getDigest();
        protected abstract uint blockSize();
        protected abstract uint addSize();
        protected abstract void padMessage(ubyte[] data);
        protected abstract void transform(ubyte[] data);        
        ---
        
        In addition there exist two further abstract methods, these methods 
        have empty default implementations because in some cases they are not required:
        ---
        protected abstract void padLength(ubyte[] data, ulong length);
        protected abstract void extend();
        ---
        The method padLength() is required to implement the SHA series of 
        ciphers and also the Tiger algorithm, extend() is required only to 
        implement the MD2 cipher.
        
        The basic sequence of events as it happens internally is as follows:
        $(UL
        $(LI transform(), 0 or more times)
        $(LI padMessage())
        $(LI padLength())
        $(LI transform())
        $(LI extend())
        $(LI getDigest())
        )

*******************************************************************************/</span>

<span class='kw4'>class</span> Cipher
<span class='opr'>{</span>
        <span class='kw4'>private</span> <span class='kw4'>uint</span>    bytes;
        <span class='kw4'>private</span> <span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> buffer;

        <span class='com'>/***********************************************************************
        
                Obtain the digest

                Returns:
                the digest

                Remarks:
                Returns a digest of the current cipher state, this may be the
                final digest, or a digest of the state between calls to update()

        ***********************************************************************/</span>

        <span class='kw4'>public</span> <span class='kw4'>abstract</span> Digest getDigest<span class='opr'>(</span><span class='opr'>)</span>;
        
        <span class='com'>/***********************************************************************

                Cipher block size

                Returns:
                the block size

                Remarks:
                Specifies the size (in bytes) of the block of data to pass to 
                each call to transform().
        
        ***********************************************************************/</span>

        <span class='kw4'>protected</span> <span class='kw4'>abstract</span> <span class='kw4'>uint</span> blockSize<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Length padding size

                Returns:
                the length paddding size

                Remarks:
                Specifies the size (in bytes) of the padding which uses the
                length of the data which has been ciphered, this padding is
                carried out by the padLength method.
        
        ***********************************************************************/</span>

        <span class='kw4'>protected</span> <span class='kw4'>abstract</span> <span class='kw4'>uint</span> addSize<span class='opr'>(</span><span class='opr'>)</span>;

        <span class='com'>/***********************************************************************
        
                Pads the cipher data

                Params: 
                data = a slice of the cipher buffer to fill with padding
                
                Remarks:
                Fills the passed buffer slice with the appropriate padding for 
                the final call to transform(). This padding will fill the cipher
                buffer up to blockSize()-addSize().

        ***********************************************************************/</span>

        <span class='kw4'>protected</span> <span class='kw4'>abstract</span> <span class='kw4'>void</span> padMessage<span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> data<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Performs the length padding

                Params: 
                data   = the slice of the cipher buffer to fill with padding
                length = the length of the data which has been ciphered
                
                Remarks:
                Fills the passed buffer slice with addSize() bytes of padding
                based on the length in bytes of the input data which has been
                ciphered.
        
        ***********************************************************************/</span>

        <span class='kw4'>protected</span> <span class='kw4'>abstract</span> <span class='kw4'>void</span> padLength<span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> data, <span class='kw4'>ulong</span> length<span class='opr'>)</span> <span class='opr'>{</span><span class='opr'>}</span>

        <span class='com'>/***********************************************************************
        
                Performs the cipher on a block of data

                Params: 
                data = the block of data to cipher
                
                Remarks:
                The actual cipher algorithm is carried out by this method on
                the passed block of data. This method is called for every 
                blockSize() bytes of input data and once more with the remaining
                data padded to blockSize().

        ***********************************************************************/</span>

        <span class='kw4'>protected</span> <span class='kw4'>abstract</span> <span class='kw4'>void</span> transform<span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> data<span class='opr'>)</span>;

        <span class='com'>/***********************************************************************

                Final processing of cipher.

                Remarks:
                This method is called after the final transform just prior to
                the creation of the final digest. The MD2 algorithm requires
                an additional step at this stage. Future ciphers may or may not
                require this method.
        
        ***********************************************************************/</span>

        <span class='kw4'>protected</span> <span class='kw4'>abstract</span> <span class='kw4'>void</span> extend<span class='opr'>(</span><span class='opr'>)</span> <span class='opr'>{</span><span class='opr'>}</span>     
        
        <span class='com'>/***********************************************************************
        
                Construct a cipher

                Remarks:
                Constructs the internal buffer for use by the cipher, the buffer
                size (in bytes) is defined by the abstract method blockSize().

        ***********************************************************************/</span>

        <span class='kw2'>this</span><span class='opr'>(</span><span class='opr'>)</span>
        <span class='opr'>{</span>
                buffer <span class='opr'>=</span> <span class='kw2'>new</span> <span class='kw4'>ubyte</span><span class='opr'>[</span>blockSize<span class='opr'>(</span><span class='opr'>)</span><span class='opr'>]</span>;
        <span class='opr'>}</span>
        
        <span class='com'>/***********************************************************************
        
                Cipher the complete set of data

                Params: 
                data = the set of data to cipher
                
                Returns:
                the completed digest

                Remarks:
                Performs the cipher on the complete set of data and produces
                the final digest.

        ***********************************************************************/</span>

        Digest sum<span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> data<span class='opr'>)</span>
        <span class='opr'>{</span>
                start<span class='opr'>(</span><span class='opr'>)</span>;
                update<span class='opr'>(</span>data<span class='opr'>)</span>;
                <span class='kw1'>return</span> finish<span class='opr'>(</span><span class='opr'>)</span>;
        <span class='opr'>}</span>

        <span class='com'>/***********************************************************************

                Initialize the cipher

                Remarks:
                Returns the cipher state to it's initial value
        
        ***********************************************************************/</span>

        <span class='kw4'>void</span> start<span class='opr'>(</span><span class='opr'>)</span>
        <span class='opr'>{</span>
                bytes <span class='opr'>=</span> <span class='nbr'>0</span>;
        <span class='opr'>}</span>
        
        <span class='com'>/***********************************************************************
        
                Cipher additional data

                Params: 
                input = the data to cipher
                
                Remarks:
                Continues the cipher operation on the additional data.

        ***********************************************************************/</span>

        <span class='kw4'>void</span> update<span class='opr'>(</span><span class='kw4'>void</span><span class='opr'>[</span><span class='opr'>]</span> input<span class='opr'>)</span>
        <span class='opr'>{</span>
                <span class='kw4'>uint</span> i;
                <span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> data <span class='opr'>=</span> <span class='kw2'>cast</span><span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span>input;
                
                i <span class='opr'>=</span> bytes <span class='opr'>&amp;</span> <span class='opr'>(</span>blockSize<span class='opr'>-</span><span class='nbr'>1</span><span class='opr'>)</span>;
                bytes <span class='opr'>+=</span> data.length;

                <span class='kw1'>if</span> <span class='opr'>(</span>data.length<span class='opr'>+</span>i <span class='opr'>&lt;</span> blockSize<span class='opr'>)</span> <span class='opr'>{</span>
                        buffer<span class='opr'>[</span>i<span class='opr'>..</span>i<span class='opr'>+</span>data.length<span class='opr'>]</span> <span class='opr'>=</span> data<span class='opr'>[</span><span class='opr'>]</span>;
                        <span class='kw1'>return</span> ;
                <span class='opr'>}</span>
                
                buffer<span class='opr'>[</span>i<span class='opr'>..</span>blockSize<span class='opr'>]</span> <span class='opr'>=</span> data<span class='opr'>[</span><span class='nbr'>0.</span>.blockSize<span class='opr'>-</span>i<span class='opr'>]</span>;
                transform<span class='opr'>(</span>buffer<span class='opr'>)</span>;

                <span class='kw1'>for</span><span class='opr'>(</span>i <span class='opr'>=</span> blockSize<span class='opr'>-</span>i; i<span class='opr'>+</span>blockSize<span class='opr'>-</span><span class='nbr'>1</span> <span class='opr'>&lt;</span> data.length; i <span class='opr'>+=</span> blockSize<span class='opr'>)</span>
                        transform<span class='opr'>(</span>data<span class='opr'>[</span>i<span class='opr'>..</span>i<span class='opr'>+</span>blockSize<span class='opr'>]</span><span class='opr'>)</span>;

                buffer<span class='opr'>[</span><span class='nbr'>0.</span>.data.length<span class='opr'>-</span>i<span class='opr'>]</span> <span class='opr'>=</span> data<span class='opr'>[</span>i<span class='opr'>..</span>data.length<span class='opr'>]</span>;
        <span class='opr'>}</span>
        
        <span class='com'>/***********************************************************************
        
                Complete the cipher

                Returns:
                the completed digest

                Remarks:
                Concludes the cipher producing the final digest.

        ***********************************************************************/</span>

        Digest finish<span class='opr'>(</span><span class='opr'>)</span>
        <span class='opr'>{</span>
                <span class='kw4'>uint</span> i;
        
                i <span class='opr'>=</span> bytes <span class='opr'>&amp;</span> <span class='opr'>(</span>blockSize<span class='opr'>-</span><span class='nbr'>1</span><span class='opr'>)</span>;
                <span class='kw1'>if</span> <span class='opr'>(</span>i <span class='opr'>&lt;</span> blockSize<span class='opr'>-</span>addSize<span class='opr'>)</span> 
                    padMessage<span class='opr'>(</span>buffer<span class='opr'>[</span>i<span class='opr'>..</span>blockSize<span class='opr'>-</span>addSize<span class='opr'>]</span><span class='opr'>)</span>;
                <span class='kw1'>else</span> 
                   <span class='opr'>{</span>
                   padMessage<span class='opr'>(</span>buffer<span class='opr'>[</span>i<span class='opr'>..</span>blockSize<span class='opr'>]</span><span class='opr'>)</span>;
                   transform<span class='opr'>(</span>buffer<span class='opr'>)</span>;
                   <span class='opr'>(</span><span class='kw2'>cast</span><span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span>buffer<span class='opr'>)</span><span class='opr'>[</span><span class='opr'>]</span> <span class='opr'>=</span> <span class='nbr'>0</span>;
                   <span class='opr'>}</span>
                
                padLength<span class='opr'>(</span>buffer<span class='opr'>[</span>blockSize<span class='opr'>-</span>addSize<span class='opr'>..</span>blockSize<span class='opr'>]</span>,bytes<span class='opr'>)</span>;
                transform<span class='opr'>(</span>buffer<span class='opr'>)</span>;

                extend<span class='opr'>(</span><span class='opr'>)</span>;
        
                <span class='kw1'>return</span> getDigest<span class='opr'>(</span><span class='opr'>)</span>;
        <span class='opr'>}</span>
        
        <span class='com'>/***********************************************************************
        
                Converts 8 bit to 32 bit Little Endian

                Params: 
                input  = the source array
                output = the destination array
                
                Remarks:
                Converts an array of ubyte[] into uint[] in Little Endian byte order.

        ***********************************************************************/</span>

        <span class='kw4'>static</span> <span class='kw4'>final</span> <span class='kw4'>void</span> littleEndian32<span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> input, <span class='kw4'>uint</span><span class='opr'>[</span><span class='opr'>]</span> output<span class='opr'>)</span>
        <span class='opr'>{</span>
                <span class='kw2'>assert</span><span class='opr'>(</span>output.length <span class='opr'>=</span><span class='opr'>=</span> input.length/<span class='nbr'>4</span><span class='opr'>)</span>;
                output<span class='opr'>[</span><span class='opr'>]</span> <span class='opr'>=</span> <span class='kw2'>cast</span><span class='opr'>(</span><span class='kw4'>uint</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span> input;

                <span class='kw4'>version</span> <span class='opr'>(</span>BigEndian<span class='opr'>)</span>
                         ByteSwap.swap32 <span class='opr'>(</span>output.ptr, output.length <span class='opr'>*</span> <span class='kw4'>uint</span>.sizeof<span class='opr'>)</span>;
        <span class='opr'>}</span>

        <span class='com'>/***********************************************************************

                Converts 8 bit to 32 bit Big Endian

                Params: 
                input  = the source array
                output = the destination array
                
                Remarks:
                Converts an array of ubyte[] into uint[] in Big Endian byte order.
        
        ***********************************************************************/</span>

        <span class='kw4'>static</span> <span class='kw4'>final</span> <span class='kw4'>void</span> bigEndian32<span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> input, <span class='kw4'>uint</span><span class='opr'>[</span><span class='opr'>]</span> output<span class='opr'>)</span>
        <span class='opr'>{</span>
                <span class='kw2'>assert</span><span class='opr'>(</span>output.length <span class='opr'>=</span><span class='opr'>=</span> input.length/<span class='nbr'>4</span><span class='opr'>)</span>;
                output<span class='opr'>[</span><span class='opr'>]</span> <span class='opr'>=</span> <span class='kw2'>cast</span><span class='opr'>(</span><span class='kw4'>uint</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span> input;

                <span class='kw4'>version</span><span class='opr'>(</span>LittleEndian<span class='opr'>)</span>
                        ByteSwap.swap32 <span class='opr'>(</span>output.ptr, output.length <span class='opr'>*</span>  <span class='kw4'>uint</span>.sizeof<span class='opr'>)</span>;
        <span class='opr'>}</span>

        <span class='com'>/***********************************************************************

                Converts 8 bit to 64 bit Little Endian

                Params: 
                input  = the source array
                output = the destination array
                
                Remarks:
                Converts an array of ubyte[] into ulong[] in Little Endian byte order.
        
        ***********************************************************************/</span>

        <span class='kw4'>static</span> <span class='kw4'>final</span> <span class='kw4'>void</span> littleEndian64<span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> input, <span class='kw4'>ulong</span><span class='opr'>[</span><span class='opr'>]</span> output<span class='opr'>)</span>
        <span class='opr'>{</span>
                <span class='kw2'>assert</span><span class='opr'>(</span>output.length <span class='opr'>=</span><span class='opr'>=</span> input.length/<span class='nbr'>8</span><span class='opr'>)</span>;
                output<span class='opr'>[</span><span class='opr'>]</span> <span class='opr'>=</span> <span class='kw2'>cast</span><span class='opr'>(</span><span class='kw4'>ulong</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span> input;

                <span class='kw4'>version</span> <span class='opr'>(</span>BigEndian<span class='opr'>)</span>
                         ByteSwap.swap64 <span class='opr'>(</span>output.ptr, output.length <span class='opr'>*</span> <span class='kw4'>ulong</span>.sizeof<span class='opr'>)</span>;
        <span class='opr'>}</span>

        <span class='com'>/***********************************************************************
        
                Converts 8 bit to 64 bit Big Endian

                Params: 
                input  = the source array
                output = the destination array
                
                Remarks:
                Converts an array of ubyte[] into ulong[] in Big Endian byte order.

        ***********************************************************************/</span>

        <span class='kw4'>static</span> <span class='kw4'>final</span> <span class='kw4'>void</span> bigEndian64<span class='opr'>(</span><span class='kw4'>ubyte</span><span class='opr'>[</span><span class='opr'>]</span> input, <span class='kw4'>ulong</span><span class='opr'>[</span><span class='opr'>]</span> output<span class='opr'>)</span>
        <span class='opr'>{</span>
                <span class='kw2'>assert</span><span class='opr'>(</span>output.length <span class='opr'>=</span><span class='opr'>=</span> input.length/<span class='nbr'>8</span><span class='opr'>)</span>;
                output<span class='opr'>[</span><span class='opr'>]</span> <span class='opr'>=</span> <span class='kw2'>cast</span><span class='opr'>(</span><span class='kw4'>ulong</span><span class='opr'>[</span><span class='opr'>]</span><span class='opr'>)</span> input;

                <span class='kw4'>version</span> <span class='opr'>(</span>LittleEndian<span class='opr'>)</span>
                         ByteSwap.swap64 <span class='opr'>(</span>output.ptr, output.length <span class='opr'>*</span> <span class='kw4'>ulong</span>.sizeof<span class='opr'>)</span>;
        <span class='opr'>}</span>

        <span class='com'>/***********************************************************************
        
                Rotate left by n

                Params: 
                x = the value to rotate
                n = the amount to rotate by
                
                Remarks:
                Rotates a 32 bit value by the specified amount.

        ***********************************************************************/</span>

        <span class='kw4'>static</span> <span class='kw4'>final</span> <span class='kw4'>uint</span> rotateLeft<span class='opr'>(</span><span class='kw4'>uint</span> x, <span class='kw4'>uint</span> n<span class='opr'>)</span>
        <span class='opr'>{</span>       
                <span class='kw4'>version</span> <span class='opr'>(</span>D_InlineAsm_X86<span class='opr'>)</span> 
                        <span class='kw4'>version</span> <span class='opr'>(</span>DigitalMars<span class='opr'>)</span> 
                        <span class='opr'>{</span>
                        <span class='kw2'>asm</span> <span class='opr'>{</span>
                            naked;
                            mov ECX,EAX;
                            mov EAX,<span class='nbr'>4</span><span class='opr'>[</span>ESP<span class='opr'>]</span>;
                            rol EAX,CL;
                            ret <span class='nbr'>4</span>;
                            <span class='opr'>}</span>
                        <span class='opr'>}</span>
                     <span class='kw1'>else</span> 
                        <span class='kw1'>return</span> <span class='opr'>(</span>x <span class='opr'>&lt;</span><span class='opr'>&lt;</span> n<span class='opr'>)</span> | <span class='opr'>(</span>x <span class='opr'>&gt;</span><span class='opr'>&gt;</span> <span class='opr'>(</span><span class='nbr'>32</span><span class='opr'>-</span>n<span class='opr'>)</span><span class='opr'>)</span>;
                <span class='kw1'>else</span> 
                   <span class='kw1'>return</span> <span class='opr'>(</span>x <span class='opr'>&lt;</span><span class='opr'>&lt;</span> n<span class='opr'>)</span> | <span class='opr'>(</span>x <span class='opr'>&gt;</span><span class='opr'>&gt;</span> <span class='opr'>(</span><span class='nbr'>32</span><span class='opr'>-</span>n<span class='opr'>)</span><span class='opr'>)</span>;
        <span class='opr'>}</span>
<span class='opr'>}</span>


</pre></td></tr></table>	</body>
</html>
