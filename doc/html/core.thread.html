<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>tango.core.thread</title>
	</head><body>
	<h1>tango.core.thread</h1>
	<!-- Generated by Ddoc from thread.d -->
The <u>thread</u> module provides support for <u>thread</u> creation and management.
<br><br>
Design Issues:
<br><br>

 One design goal of Ares is to avoid forcing the use of a particular
 programming style, so long as allowing such flexibility does not
 compromise the overall API design.  This goal was realized here by
 allowing threads to be created in the familiar C style (ie. by
 composition), or by derivation, similar to the Java style.  Composition
 is further supported by virtue of the <u>thread</u> local storage facility,
 which allows for <u>thread</u> local data to be stored by the main <u>thread</u> as
 well as by user threads.
<br><br>

 Future Directions:
<br><br>

 Support for lightwewight user threads is a long-term consideration,
 though the design of this module is largely settled for now.
 
<br><br>

<dl><dt><big>class <u>ThreadError</u>: object.Exception;
</big></dt>
<dd>All exceptions thrown from this module derive from this class.
 
<br><br>

<dl></dl>
</dd>
<dt><big>class <u>Thread</u>;
</big></dt>
<dd>This class encapsulates all threading functionality for the D
 programming language.  As thread manipulation is a required facility
 for garbage collection, all user threads should derive from this
 class, and instances of this class should never be explicitly deleted.
 A new thread may be created using either derivation or composition, as
 in the following example.
<br><br>
<b>Example:</b><br>
<pre class="d_code">
 <font color=blue>class</font> DerivedThread : <u>Thread</u>
 {
     <font color=blue>void</font> run()
     {
         printf( <font color=red>"Derived thread running.\n"</font> );
     }
 }

 <font color=blue>void</font> threadFunc()
 {
     printf( <font color=red>"Composed thread running.\n"</font> );
 }

 <font color=green>// create instances of each type
</font> <u>Thread</u> derived = <font color=blue>new</font> DerivedThread();
 <u>Thread</u> composed = <font color=blue>new</font> <u>Thread</u>( &amp;threadFunc );

 <font color=green>// start both threads
</font> derived.start();
 composed.start();

 <font color=green>// wait for the threads to complete
</font> derived.join();
 composed.join();

</pre>
 
<br><br>

<dl><dt><big>this();
</big></dt>
<dd>Initializes a thread object which has no associated executable
 function.
     
<br><br>

</dd>
<dt><big>this(void(* <i>fn</i>)());
</big></dt>
<dd>Initialized a thread object which is associated with a static
 D function.
<br><br>
<b>Params:</b><br>
<table><tr><td>void(* <i>fn</i>)()</td>
<td>The thread function.</td></tr>
</table><br>

</dd>
<dt><big>this(void delegate() <i>dg</i>);
</big></dt>
<dd>Initializes a thread object which is associated with a dynamic
 D function.
<br><br>
<b>Params:</b><br>
<table><tr><td>void delegate() <i>dg</i></td>
<td>The thread function.</td></tr>
</table><br>

</dd>
<dt><big>final void <u>start</u>();
</big></dt>
<dd>Starts the thread with run() as the target method.  The default
 behavior of this is to run the function or delegate passed upon
 construction.
<br><br>
<b>In:</b><br>
This routine may only be called once per thread instance.

<br><br>
<b>Throws:</b><br>
ThreadError if the thread fails to <u>start</u>.
     
<br><br>

</dd>
<dt><big>final void <u>join</u>();
</big></dt>
<dd>Waits for this thread to complete.
<br><br>
<b>Throws:</b><br>
ThreadError if the operation fails.
     
<br><br>

</dd>
<dt><big>final char[] <u>name</u>();
</big></dt>
<dd>Gets the user-readable label for this thread.
<br><br>
<b>Returns:</b><br>
The <u>name</u> of this thread.
     
<br><br>

</dd>
<dt><big>final void <u>name</u>(char[] <i>n</i>);
</big></dt>
<dd>Sets the user-readable label for this thread.
<br><br>
<b>Params:</b><br>
<table><tr><td>char[] <i>n</i></td>
<td>The new <u>name</u> for this thread.</td></tr>
</table><br>

</dd>
<dt><big>final bool <u>isRunning</u>();
</big></dt>
<dd>Tests whether this thread is running.  This function should be
 callable from anywhere within the application without a risk of
 deadlock.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the thread is running, <b>false</b> if not.
     
<br><br>

</dd>
<dt><big>static void <u>sleep</u>(Interval <i>interval</i> = cast(Interval)60000000u);
</big></dt>
<dd>Suspends the calling thread for at least the supplied time.
<br><br>
<b>Params:</b><br>
<table><tr><td>Interval <i>interval</i></td>
<td>The minimum duration the calling thread should be
             suspended.  If <i>interval</i> is equal to Interval.max
             then the thread will <u>sleep</u> forever.</td></tr>
</table><br>

</dd>
<dt><big>static void <u>yield</u>();
</big></dt>
<dd>Forces a context switch to occur away from the calling thread.
     
<br><br>

</dd>
<dt><big>static Thread <u>getThis</u>();
</big></dt>
<dd>The calling thread.
<br><br>
<b>Returns:</b><br>
The thread object representing the calling thread.  The result of
  deleting this object is undefined.
     
<br><br>

</dd>
<dt><big>static Thread[] <u>getAll</u>();
</big></dt>
<dd>This function is not intended to be used by the garbage collector,
 so memory allocation is allowed.
<br><br>
<b>Returns:</b><br>
An array containing references to all threads currently being
  tracked by the system.  The result of deleting any contained
  objects is undefined.
     
<br><br>

</dd>
<dt><big>static int <u>opApply</u>(int delegate(inout Thread) <i>dg</i>);
</big></dt>
<dd>Operates on all threads currently tracked by the system.
<br><br>
<b>Params:</b><br>
<table><tr><td>int delegate(inout Thread) <i>dg</i></td>
<td>The supplied code as a delegate.</td></tr>
</table><br>
<b>Returns:</b><br>
Zero if all elemented are visited, nonzero if not.
     
<br><br>

</dd>
<dt><big>const uint <u>LOCAL_MAX</u>;
</big></dt>
<dd>Indicates the number of local storage pointers available at program
 startup.  It is recommended that this number be at least 64.
     
<br><br>

</dd>
<dt><big>static uint <u>createLocal</u>();
</big></dt>
<dd>Reserves a local storage pointer for use and initializes this
 location to <b>null</b> for all running threads.
<br><br>
<b>Returns:</b><br>
A key representing the array offset of this memory location.
     
<br><br>

</dd>
<dt><big>static void <u>deleteLocal</u>(uint <i>key</i>);
</big></dt>
<dd>Marks the supplied <i>key</i> as available and sets the associated location
 to <b>null</b> for all running threads.  It is assumed that any <i>key</i> passed
 to this function is valid.  The result of calling this function for
 a <i>key</i> which is still in use is undefined.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>key</i></td>
<td>The <i>key</i> to delete.</td></tr>
</table><br>

</dd>
<dt><big>static void* <u>getLocal</u>(uint <i>key</i>);
</big></dt>
<dd>Gets the data associated with the supplied <i>key</i> value.  It is assumed
 that any <i>key</i> passed to this function is valid.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>key</i></td>
<td>The location which holds the desired data.</td></tr>
</table><br>
<b>Returns:</b><br>
The data associated with the supplied <i>key</i>.
     
<br><br>

</dd>
<dt><big>static void* <u>setLocal</u>(uint <i>key</i>, void* <i>val</i>);
</big></dt>
<dd>Stores the supplied value in the specified location.  It is assumed
 that any <i>key</i> passed to this function is valid.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>key</i></td>
<td>The location to store the supplied data.</td></tr>
<tr><td>void* <i>val</i></td>
<td>The data to store.</td></tr>
</table><br>
<b>Returns:</b><br>
A copy of the data which has just been stored.
     
<br><br>

</dd>
<dt><big>protected void <u>run</u>();
</big></dt>
<dd>This is the entry point for the newly invoked thread.  Default
 behavior is to call the function or delegate passed on object
 construction.  This function may be overridden to create custom
 thread objects via subclassing.
     
<br><br>

</dd>
</dl>
</dd>
<dt><big>void <u>thread_init</u>();
</big></dt>
<dd>Initializes the thread module.  This function must be called by the
 garbage collector on startup and before any other thread routines.
 are called.
<br><br>
Please note that if <u>thread_init</u> itself performs any allocations then
 the thread routines reserved for garbage collector use may be called
 while <u>thread_init</u> is being processed.  However, since no memory should
 exist to be scanned at this point, it is sufficient for these functions
 to detect the condition and return immediately.
 
<br><br>

</dd>
<dt><big>bool <u>thread_needLock</u>();
</big></dt>
<dd>This function is used to determine whether the the process is
 multi-threaded.  Optimizations may only be performed on this
 value if the programmer can guarantee that no path from the
 enclosed code will start a thread.
<br><br>
<b>Returns:</b><br>
True if Thread.start() has been called in this process.
 
<br><br>

</dd>
<dt><big>void <u>thread_suspendAll</u>();
</big></dt>
<dd>Suspend all threads but the calling thread for "stop the world" garbage
 collection runs.  This function may be called multiple times, and must
 be followed by a matching number of calls to thread_resumeAll before
 processing is resumed.
<br><br>
<b>Throws:</b><br>
ThreadException if the suspend operation fails for a running thread.
 
<br><br>

</dd>
<dt><big>void <u>thread_resumeAll</u>();
</big></dt>
<dd>Resume all threads but the calling thread for "stop the world" garbage
 collection runs.  This function must be called once for each preceding
 call to thread_suspendAll before the threads are actually resumed.
<br><br>
<b>In:</b><br>
assert( suspendDepth &gt; 0 );

<br><br>
<b>Throws:</b><br>
ThreadException if the resume operation fails for a running thread.
 
<br><br>

</dd>
<dt><big>void <u>thread_scanAll</u>(void delegate(void*, void*) <i>fn</i>, void* <i>curStackTop</i> = null);
</big></dt>
<dd>The main entry point for garbage collection.  The supplied delegate
 will be passed ranges representing both stack and register values.
<br><br>
<b>Params:</b><br>
<table><tr><td>void delegate(void*, void*) <i>fn</i></td>
<td>The scanner function.  It should scan from p1 through p2 - 1.</td></tr>
<tr><td>void* <i>curStackTop</i></td>
<td>An optional pointer to the top of the calling thread's stack.</td></tr>
</table><br>

</dd>
<dt><big>class <u>ThreadGroup</u>;
</big></dt>
<dd>This class is intended to simplify certain common programming techniques.
 
<br><br>

<dl><dt><big>Thread <u>create</u>(void(* <i>fn</i>)());
</big></dt>
<dd>Creates and starts a new Thread object that executes <i>fn</i> and
 adds it to the list of tracked threads.
<br><br>
<b>Params:</b><br>
<table><tr><td>void(* <i>fn</i>)()</td>
<td>The thread function.</td></tr>
</table><br>
<b>Returns:</b><br>
A reference to the newly created thread.
     
<br><br>

</dd>
<dt><big>Thread <u>create</u>(void delegate() <i>dg</i>);
</big></dt>
<dd>Creates and stats a new Thread object that executes <i>dg</i> and
 adds it to the list of tracked threads.
<br><br>
<b>Params:</b><br>
<table><tr><td>void delegate() <i>dg</i></td>
<td>The thread function.</td></tr>
</table><br>
<b>Returns:</b><br>
A reference to the newly created thread.
     
<br><br>

</dd>
<dt><big>void <u>add</u>(Thread <i>t</i>);
</big></dt>
<dd>Add <i>t</i> to the list of tracked threads if it is not already being
 tracked.
<br><br>
<b>Params:</b><br>
<table><tr><td>Thread <i>t</i></td>
<td>The thread to <u>add</u>.</td></tr>
</table><br>
<b>In:</b><br>
assert( <i>t</i> );
     
<br><br>

</dd>
<dt><big>void <u>remove</u>(Thread <i>t</i>);
</big></dt>
<dd>Removes <i>t</i> from the list of tracked threads.  No operation will be
 performed if <i>t</i> is not currently being tracked by this object.
<br><br>
<b>Params:</b><br>
<table><tr><td>Thread <i>t</i></td>
<td>The thread to <u>remove</u>.</td></tr>
</table><br>
<b>In:</b><br>
assert( <i>t</i> );
     
<br><br>

</dd>
<dt><big>int <u>opApply</u>(int delegate(inout Thread) <i>dg</i>);
</big></dt>
<dd>Operates on all threads currently tracked by this object.
     
<br><br>

</dd>
<dt><big>void <u>joinAll</u>(bool <i>preserve</i> = true);
</big></dt>
<dd>Iteratively joins all tracked threads.  This function
 will block add, remove, and opApply until it completes.
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>preserve</i></td>
<td>Preserve thread references.</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. </small>
	</body></html>
